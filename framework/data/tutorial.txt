## What is PSI-Toolkit? ##

PSI-Toolkit is an open-source set of linguistic tools for processing text
written in various formats and various languages. In particular, it deals with:

* text pre-processing
* sentence splitting
* tokenization
* lexical and morhological analysis
* syntactical parsing
* machine translation

The PSI tools process mainly but not exclusively texts written in Polish. At
this moment supported languages are also: English, French, Turkish, German,
Russian, Italian and probably some others.


## How to use the PSI-Toolkit? ##

The easiest way to use PSI-Toolkit is either use our web-service called
[PSI-Server](/) or download the [Linux packages](/download.html) and use them
locally with command-line program `psi-pipe`.

The installation process is described in the [Installation guide]
(/help/install.html).
Note that, after installing PSI-Toolkit from precompiled packages you will
also get the own instance of PSI-Server (with exactly the same functionalities)
to run locally by simple typing `psi-server` and typing `http://localhost:3000`
address in your web browser.


# Usage basics #

Typical usage of PSI-Toolkit consists of choosing input data to process and
setting appropriate command which let you specify what you want to do, for
instance, to `tokenize` or to `lemmatize`.
The basic explanation of writting commands via the PSI-Server with suitable
screen shots is included in [Getting started](/help/start.html).

The command (we also refers to _command_ by using _pipeline_)usually is a
sequence of three tasks: read, annotate and write because data have to be
firstly read, then processed (annotated) and finally displayed.
Each task is realized with tool so-called reader, processor or writer
respectively, each separated from each other by `!` sign.
Hence, a standard pipeline has the following structure:

    a reader ! a sequence of processors ! a writer

The list of all available tools is available in [Documentation]
(/help.documentation.html).


## Example ##

Lets assume that we need to split the sentence _Piękna gra trwała długo._
into tokens, i.e. we want to tokenize them. It can be done with command:

    read-text ! tokenize ! write-simple

As we can see, each task is separated by an exclamation point.
The sequence of tasks (processors) determine the sequence of text processing
and should be logically correct (reading at the beginning, writing at the end,
lemmatization placed after tokenization, etc.).

The expected result is ([click here to run this example in new window](/pipe.psis?pipe-text=read-text+!+tokenize+!+write-simple&input-text=Piękna+gra+trwała+długo.)):

    Piękna
    gra
    trwała
    długo
    .

Another example can be lemmatization of the same sentence and displaying
all lemmas for each word, which is possible with command:

    read-text ! tokenize ! lemmatize ! write-simple --tag lemma

and the result is ([run example](/pipe.psis?pipe-text=read-text+!+tokenize+!+lemmatize+!+write-simple&input-text=Piękna+gra+trwała+długo.)):

    piękno|piękny
    gra|grać
    trwać|trwała|trwały
    długo

There we need to precisely say what we want to display by setting the
`--tag lemma` switches for `write-simple`, otherwise we get output in internal
PSI-Toolkit format (see section *Working with PSI-lattice* for details).


## Processor switches ##

As was pointed in previous example, the use of the PSI processor may be
customized be means of switches (options). Most of the options requires
a value, as it is in the case of the previously mentioned `--tag` option
(the value was `lemma`).

All available options for each processor you will find in [Documentation]
(/help/documentation.html).


## Auto completion ##

You do not have to specify all processors in your command. If you "forget"
a processor, the pipeline will be supplemented by the default processor. For
example, the much simpler command:

    tokenize

return exactly the same results as previous once ([run example](/pipe.psis?pipe-text=tokenize&input-text=Piękna+gra+trwała+długo.))

    read-text ! tokenize ! write-simple

because missing but necessary tasks will be complement automatically.
Hence, the following pipelines are usually equal for the same input:

* `read-text ! tokenize ! lemmatize ! write-simple --tag lemma`
* `lemmatize ! write-simple --tag lemma` - both, the reader and necessary
processor will be autocomplement.


## Aliases ##

Most of the tasks can be expressed either as a verb (e.g. `tokenize`), as a
noun (`tokenizer`) or as a specific tool's name (`tp-tokenizer`). Such
alternative names are called _aliases_, and are always listed in processor's
description in [Documentation](/help/documentation.html) or on the
[List of aliases](/help/aliases.html).

For example the following pipelines are equal:

* `segment ! write --tag segment`
* `srx-segmenter ! simple-writer --tag segment`


## More examples ##

More working examples are available with the _random example_ button located
under _write command_ input field on the main PSI-Server website. Using it you
can easily run predefined commands.
The same examples can be found in [Documentation](/help/documentation.html)
within each processor's description.


# Other features #

## PSI-readers ##

Readers process input either from keyboard or from a file. PSI-Toolkit
supports such formats as: `txt`, `html`, `doc`, `docx`, `xlsx`, `pptx` and
`pdf` by many available readers. Instead of specifying reader implicite, you
may use `guessing-reader` and PSI-Toolkit tries to recognize the input file
format for you.


## Working with PSI-lattice ##

Processed data are stored into the internal data structure, a so-called
PSI-lattice. If you want to see how a PSI-lattice looks like in graphical
format, try this command with quite simple input text:

    tokenize ! graph --format png

You can also display PSI-lattice in textual format with `psi-writer` tool
(alias is `write-psi`):

    tokenize ! write-psi

For input _Piękna gra trwała długo._ it returns:

    ## beg. len.  text         tags                  annot.text  annotations
    01 0000 07    Piękna       !pl,token             Piękna      T
    02 0007 01    _            !pl,token             _           B
    03 0008 03    gra          !pl,token             gra         T
    04 0011 01    _            !pl,token             _           B
    05 0012 07    trwała       !pl,token             trwała      T
    06 0019 01    _            !pl,token             _           B
    07 0020 06    długo        !pl,token             długo       T
    08 0000 27    Piękna_gra_trwała_długo. frag,txt-reader Piękna_gra_trwała_długo. FRAG[]
    09 0000 27    Piękna...go. !pl,lang-guesser,text Piękna_gra_trwała_długo. TEXT[8]
    10 0026 01    .            !pl,token             .           I

This format is called PSI-format and for detailed description read
[PSI-format](/help/documentation.html) page.

What we only want to stressed right now is the possibility of selective
extraction from PSI-lattice by given tags using `simple-writer`. Immadietly
after `--tag` option you can specify a tag that should be written to output.
For previous example, printing only `token` tags (see fifth column in
PSI-format) is possible with command ([run example](/pipe.psis?pipe-text=tokenize+!+write-simple+--tag+token&input-text=Piękna+gra+trwała+długo.)):

    tokenize ! write-simple --tag token

It was also presented with the example of lemmatization:

    lemmatize ! write-simple --tag lemma


## Command-line program ##

The command-line program called `psi-pipe` is available after installation of
PSI-Toolkit package. Using it requires a basic knowledge about console
commands, but everyone who use a Unix terminal will be familiar.

We can pass the pipeline as was described before as arguments for `psi-pipe`
program. To pass input text to the standard input we need to use `echo` Unix
command and standard pipeline (i.e. the vertical bar `|`):

    $ echo "Piękna gra trwała długo." | lemmatize ! write-simple --tag lemma

If you want to pass a file instead of raw text, you may use `cat` command:

    $ cat ../path-to-your/file.docx | lemmatize ! write-simple --tag lemma


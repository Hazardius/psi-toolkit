#  Copyright (C) 2007-2011 Poleng Sp. z o.o.
#
#  This file can be redistributed and/or modified under the terms of the
#  GNU Lesser General Public Licence as published by the Free Software
#  Foundation.

#!!! TRACE czasownik.i

#

#

sub ::contraction(c)
{
    if(not get_option(no_contractions))
        return $c;

    if($c = "won't")
    {
        if(get_option(use_shall) or get_option("use_shall1"))
            return "shall not";
        else
            return "will not";
    }

    if($c = "isn't")     return "is not";
    if($c = "aren't")    return "are not";
    if($c = "wasn't")    return "was not";
    if($c = "weren't")   return "were not";
    if($c = "can't")     return "cannot";
    if($c = "couldn't")  return "could not";
    if($c = "doesn't")   return "does not";
    if($c = "don't")     return "do not";
    if($c = "didn't")    return "did not";
    if($c = "wouldn't")  return "would not";
    if($c = "hasn't")    return "has not";
    if($c = "haven't")   return "have not";
    if($c = "hadn't")    return "had not";
    if($c = "shouldn't") return "should not";

    warning("unknown contraction:"+$c);
    return $c;
}

sub ::will_or_shall()
{
    if(get_option(use_shall) or get_option("use_shall1"))
        return "shall";

    return "will";
}

sub ::inflect_be_present(person, number, neg)
{
    if($neg)
    {
        if($number = 1 and $person = 1)
            return "am not";

        if($number = 1 and $person = 3)
            return contraction("isn't");

        return contraction("aren't");
    }
    else
    {
        if($number = 1 and $person = 1)
            return "am";

        if($number = 1 and $person = 3)
            return "is";

        return "are";
    }
}

sub ::inflect_be_past(person, number, neg)
{
    if($neg)
    {
        if($number = 1 and $person != 2)
            return contraction("wasn't");

        return contraction("weren't");
    }
    else
    {
        if($number = 1 and $person != 2)
            return "was";

        return "were";
    }
}

#

sub V::first_aux()
{
    if(Aux)
    {
        if(Equiv = "can")
        {
            if(Tense =~ /^past/ or Tense =~ /^conditional/)
                return "could";
            else if(Tense =~ /^gerund/)
            {
                if(Neg)
                    return "not being able to";
                else
                    return "being able to";
            }
            else if(Tense =~ /^future/)
            {
                return will_or_shall();
            }

            if(Neg)
            {
                NegInAux := 1;
                return "cannot";
            }
        }
        else if(Equiv = "may")
        {
            if(Tense =~ /^past/ or Tense =~ /^conditional/)
                return "might";
            else if(Tense =~ /^gerund/)
            {
                if(Neg)
                    return "not being allowed to";
                else
                    return "being allowed to";
            }

        }

        return Equiv;
    }

    if(Can)
    {
        if(Tense = present)
        {
            if(Neg)
            return contraction("can't");

            return "can";
        }

        if(Tense = past)
        {
            if(Neg)
            return contraction("couldn't");

            return "could";
        }
    }

    if(Neg)
    {
        if(Tense = present)
        {
            if(Voice = passive or Be)
            {
                if(Person = 1 and Num = 1)
                    return "am";
                else
                    return inflect_be_present(Person, Num, 1);
            }
            else if(Person = 3 and Num = 1)
                return contraction("doesn't");
            else
                return contraction("don't");
        }

        if(Tense = present_continuous)
        {
            if(Person = 1 and Num = 1)
                return "am";
            else
                return inflect_be_present(Person, Num, 1);
        }

        if(Tense = past)
        {
            if(Voice = passive or Be)
                return inflect_be_past(Person, Num, 1);
            else
                return contraction("didn't");
        }

        if(Tense = past_continuous)
            return inflect_be_past(Person, Num, 1);

        if(Tense = future)
            return contraction("won't");

        if(Tense = future_continuous)
            return contraction("won't");

        if(Tense = future_past)
            return contraction("wouldn't");

        if(Tense = future_past_continuous)
            return contraction("wouldn't");

        if(Tense = present_perfect)
        {
            if(Person = 3 and Num = 1)
            return contraction("hasn't");
            else
            return contraction("haven't");
        }

        if(Tense = present_perfect_continuous)
        {
            if(Person = 3 and Num = 1)
                return contraction("hasn't");
            else
                return contraction("haven't");
        }

        if(Tense = past_perfect)
            return contraction("hadn't");

        if(Tense = future_perfect)
            return contraction("won't");

        if(Tense = conditional)
            return contraction("wouldn't");

        if(Tense = conditional_continuous)
            return contraction("wouldn't");

        if(Tense = conditional_perfect)
            return contraction("wouldn't");

        if(Tense = conditional_perfect_continuous)
            return contraction("wouldn't");

        if(Tense = subjunctive)
            return contraction("shouldn't");

        if(Tense = imperative)
        {
            if(Person = 2)
                return contraction("don't");
            else if(Person = 1 and Num = 2)
                return "let us";
            else
                return "let";
        }

        if(Tense = infinitive or Tense = to_infinitive)
            return 0;

        if(Tense = past_participle)
            return 0;

        if(Tense = gerund)
            return 0;

        if(Tense = gerund_perfect)
            return 0;
    }
    else
    {
        if(Tense = present)
        {
            if(Voice = passive or Be)
                return inflect_be_present(Person, Num, 0);
            else if(Person = 3 and Num = 1)
                return "does";
            else
                return "do";
        }

        if(Tense = present_continuous)
            return inflect_be_present(Person, Num, 0);

        if(Tense = past)
        {
            if(Voice = passive or Be)
                return inflect_be_past(Person, Num, 0);
            else
                return "did";
        }

        if(Tense = past_continuous)
            return inflect_be_past(Person, Num, 0);

        if(Tense = future)
            return will_or_shall();

        if(Tense = future_continuous)
            return will_or_shall();

        if(Tense = future_past)
            return "would";

        if(Tense = future_past_continuous)
            return "would";

        if(Tense = present_perfect)
        {
            if(Person = 3 and Num = 1)
                return "has";
            else
                return "have";
        }

        if(Tense = present_perfect_continuous)
        {
            if(Person = 3 and Num = 1)
                return "has";
            else
                return "have";
        }

        if(Tense = past_perfect)
            return "had";

        if(Tense = future_perfect)
            return will_or_shall();

        if(Tense = conditional)
            return "would";

        if(Tense = conditional_continuous)
            return "would";

        if(Tense = conditional_perfect)
            return "would";

        if(Tense = conditional_perfect_continuous)
            return "would";

        if(Tense = subjunctive)
            return "should";

        if(Tense = imperative)
        {
            if(Person = 2)
                return "do";
            else if(Person = 1 and Num = 2)
                return "let us";
            else
                return "let";
        }

        if(Tense = infinitive or Tense = to_infinitive)
            return 0;

        if(Tense = past_participle)
            return 0;

        if(Tense = gerund)
            return 0;

        if(Tense = gerund_perfect)
            return 0;
    }

    return 0;
}

sub V::neg_considered(w)
{
    if(Neg)
        return "not" & $w;

    return $w;
}


sub V::rest_aux()
{
    if(Can and (Tense = present or Tense = past))
        return 0;

    if(Voice = passive)
    {
        if(Tense = present)
        {
            if(Neg and Person = 1 and Num = 1)
                return "not";
            else
                return 0;
        }

        if(Tense = present_continuous)
        {
            if(Neg and Person = 1 and Num = 1)
                return "not being";
            else
                return "being";
        }

        if(Tense = past)
            return 0;

        if(Tense = past_continuous)
            return "being";

        if(Tense = future)
            return "be";

        if(Tense = future_continuous)
            return "be";

        if(Tense = future_past)
            return "be";

        if(Tense = future_past_continuous)
            return "be";

        if(Tense = present_perfect)
            return "been";

        if(Tense = present_perfect_continuous)
            return "been";

        if(Tense = past_perfect)
            return "been";

        if(Tense = future_perfect)
            return "been";

        if(Tense = conditional)
            return "be";

        if(Tense = conditional_continuous)
            return "be";

        if(Tense = conditional_perfect)
            return "have been";

        if(Tense = conditional_perfect_continuous)
            return "have been";

        if(Tense = subjunctive)
            return "be";

        if(Tense = imperative)
        {
            if(Neg and Person != 2)
                return "not be";

            return "be";
        }

        if(Tense = infinitive)
            return neg_considered("be");

        if(Tense = to_infinitive)
            return neg_considered("to be");


        if(Tense = past_participle)
            return neg_considered("been");

        if(Tense = gerund)
            return neg_considered("being");

        if(Tense = gerund_perfect)
            return neg_considered("having being");
    }
    else
    {
        if(Tense = present)
        {
            if(Be and Neg and Num = 1 and Person = 1)
                return "not";

            return 0;
        }

        if(Tense = present_continuous)
        {
            if(Neg and Num = 1 and Person = 1)
                return "not";
            else
                return 0;
        }

        if(Tense = past)
            return 0;

        if(Tense = past_continuous)
            return 0;

        if(Tense = future)
            return 0;

        if(Tense = future_continuous)
            return "be";

        if(Tense = future_past)
            return 0;

        if(Tense = future_past_continuous)
            return "be";

        if(Tense = present_perfect)
            return 0;

        if(Tense = present_perfect_continuous)
            return "been";

        if(Tense = past_perfect)
            return 0;

        if(Tense = past_perfect_continuous)
            return "had been";

        if(Tense = future_perfect)
            return "have";

        if(Tense = conditional)
            return 0;

        if(Tense = conditional_continuous)
            return "be";

        if(Tense = conditional_perfect)
            return "have";

        if(Tense = conditional_perfect_continuous)
            return "have been";

        if(Tense = subjunctive)
            return 0;

        if(Tense = imperative)
        {
            if(Neg and Person != 2)
                return "not";

            return 0;
        }

        if(Tense = infinitive)
            return neg_considered("");

        if(Tense = to_infinitive)
        {
            if(Aux)
            return neg_considered("");
            else
            return neg_considered("to");
        }

        if(Tense = past_participle)
            return neg_considered("");

        if(Tense = gerund)
            return neg_considered("");

        if(Tense = gerund_perfect)
            return neg_considered("having");
    }

    return 0;
}

sub V::is_aux_per_se()
{
    return Be;
}

sub V::is_aux_obligatory()
{
    if(Aux)
        return 1;

    if(Can and (Tense = present or Tense = past))
        return 1;

    if(Voice != passive and not Neg and
       (Tense = present or Tense = past)
       and not is_aux_per_se())
        return 0;

    if(Tense = imperative and not Neg and Person = 2)
        return 0;

    return 1;
}

sub V::main_mcode()
{
    if(Voice = passive)
        return "Vpp";

    if(Tense = present)
    {
        if(WithAux)
        return "";
        else
        return "Vpres";
    }

    if(Tense = present_continuous or Tense = past_continuous or
       Tense = future_continuous or Tense = future_past_continuous or
       Tense = present_perfect_continuous or
       Tense = past_perfect_continuous or
       Tense = conditional_continuous or
       Tense = conditional_perfect_continuous or
       Tense = conditional_perfect_continuous or
       Tense = gerund)
        return "Vgr";

    if(Tense = past)
    {
        if(not WithAux)
            return "Vpt";
        else
            return "";
    }

    if(Tense = present_perfect or Tense = present_perfect_continuous or
       Tense = past_perfect or Tenst = future_perfect or
       Tense = past_participle or Tense = gerund_perfect)
       return "Vpp";


    if(Tense = future or Tense = future_past or
       Tense = conditional or
       Tense = imperative or Tense = infinitive or Tense = to_infinitive or
       Tense = subjunctive)
       return "";

    warning("unknown tense: " + Tense);

    return "";
}

sub V::be_inflection(mcode,person,num,neg)
{
    if($mcode = "Vpres")
    return inflect_be_present($person,$num,$neg);

    if($mcode = "Vpast")
    return inflect_be_past($person,$num,$neg);

    if($mcode = "Vgr")
    return "being";

    if($mcode = "Vpp")
    return "been";

    return "be";
}

sub V::inflection(w,i)
{
    # instrukcja fleksyjna składa się z pięciu członów
    if($i =~ /^(.*_|(?:))([A-Za-z]+[0-9]*)-?([A-Za-z]*)(:[0-9u]+|(?:))(!?)$/)
    {
        $ia := $1; $ib := $2; $ic := $3; $id := $4; $ie := $5;

        if($ia != "")
            $name := $ia + $ib;
        else
            $name := $w + "_" + $ib;

        #    if($ic != "")
        #        $mcode := mtocode($ic);
        #    else
        #        $mcode := mtocode($ib);

        $mcode := main_mcode();

        if($mcode = "" and not Be)
            return $w;

        $num := Num;

        if($name = "be_V")
        {
            if(Tense = past or Tense = present)
                return "";
            else
                return be_inflection($mcode,Person,$num,Neg);
        }

        if(($id != "" and $id =~ /^:.*u$/) or Upper)
            return pair($name,"u" + get_enmorpho($mcode, $num, Person, 0));
        else
            return pair($name,get_enmorpho($mcode, $num, Person, 0));
    }

    warning("błędna instrukcja fleksyjna:");
    warning($i);

    return $w;
}



sub V::surface()
{
    if(Aux)
    {
        $aux_verb := Equiv;

        $f := "";

        if(Equiv = "can")
        {
            if(Tense =~ /^gerund/)
                # 'mogący oddychać' => 'being able to breathe'
                return "";
            else if(Tense =~ /^future/)
            {
                if(Neg)
                    # 'kto nie będzie mógł' => 'who will not be able to'
                    return "not be able to";
                else
                    # 'kto będzie mógł?' => 'who will be able to?'
                    return "be able to";
            }
        }
        else if(Equiv = "may")
        {
            warning('UNEXPECTED: may');
            if(Tense =~ /^gerund/)
            {
                warning('UNEXPECTED: gerund');
                return "";
            }
        }

        if(Neg and not NegInAux)
            # 'biurko nie powinno być większe' => 'the desk should not be bigger'
            $f := "not";

        return $f;
    }
    else
    {
        # 'nie chcę ani komputerów, ani drukarek, ani modemów' => 'I want neither computers, nor printers, nor modems'
            # @todo???
        $raux = rest_aux();

        if(!Inflection or Inflection = "")
        {
            if(Equiv =~ /^([^ ]+)( .*)$/)
            {
                # 'musiał czekać na niego' => 'he had to wait for him'
                return $raux & inflection($1,"V") & $2;
            }
            else
                return $raux & inflection(Equiv,"V");
        }
        else
        {
            return $raux & inflection_cycle(Equiv, Inflection);
        }
    }
}

sub Particle::surface()
{
    # @todo wstawić my/your/his etc.
    if(Equiv =~ /^(.*)PS(.*)$/ or Equiv =~ /^(.*)one\'s(.*)$/)
    {
        $pspre := $1;
        $postpre := $2;
        if (Person = 2) $ppron := "your";
        else if (Person = 1)
        {    if (Num = 1) $ppron := "my";
                else $ppron :="our";
        }
        else
        {
            if (Num = 2) $ppron := "their";
            else
            {
                if (Gender = fem or Gender = fem_or_neut) $ppron := "her";
                else if (Gender = masc or Gender = masc_or_neut) $ppron := "his";
                else $ppron := "its";
            }
        }
        if(($pspre = "" or $pspre =~ / $/) and
           ($postpre = "" or $postpre =~ /^ /))
            Equiv := $pspre + $ppron + $postpre;
    }
    return gensurface();
}

sub Conj::surface()
{
    if(parent()->cat() = "CVP" and
       $VP := parent()->find("VP",) and
       $VP->Tense = to_infinitive and
       Equiv =~ /^(.+)[_ ]to$/)
    {
        Equiv := $1;
    }

    if(find(',',))
      {Equiv := Equiv + ",";}
    if(find('-',))
      {Equiv := Equiv + " -";}
    if(find(':',))
      {Equiv := Equiv + ":";}

    return gensurface();
}

#
#
#
#
#
#
sub VP::fix_reflexive_pronouns()
{
    if(%Subject)
    {
        foreach $s
        {
            if($s != %Subject)
                $s->fix_reflexive_pronouns_with(%Subject);
        }
    }
    else if(Tense = imperative)
    {
       # 'bądź na własnym garnuszku!' => 'fend for yourself!'
       # 'bądźcie na własnym garnuszku!' => 'fend for yourselves!'
       # 'bądźmy na własnym garnuszku!' => 'let us fend for ourselves!'
       foreach $s
       $s->fix_reflexive_pronouns_with(%Head);
   }
}

#
#
#

#
sub GNP::fix_reflexive_pronouns()
{
    foreach $s
    {
        if($s->label() != "#" and $s->reflexive_with_noun())
            $s->fix_reflexive_pronouns_with(this());
    }
}
#
sub ::reflexive_with_noun()
{
    if(cat() = "SubC" or
       cat() = "VP" and Tense = gerund or
       cat() = "AdjPron" or
       label() = "possesive")
    return 0;

    return 1;
}
#
sub ::fix_reflexive_pronouns_with(subj)
{
    # 'poszedł by spotkać Annę' => 'he went in order to meet Anna'
    if(cat() = "SubC")
        return 0;

    if(Equiv)
        Equiv := fix_ones(Equiv,$subj);
    else
    {
        foreach $s
        {
            # specjalnie traktujemy GNP
            # 'lubię kobiety niepewne siebie' => 'I like women unsure of themselves'

            if(cat() = "GNP")
            {
                if($s->label()="#" or not $s->reflexive_with_noun())
                    $s->fix_reflexive_pronouns_with($subj);
                else
                    $s->fix_reflexive_pronouns_with(this());
            }
            else
                $s->fix_reflexive_pronouns_with($subj);
        }
    }
}
#
sub ::fix_ones(e,subj)
{
    if($e =~ "^([^$]*)\$(he|one('s|self|(?:)))\$(.*)")
    {
        return $1 + fix_one($2,$subj) + fix_ones($4,$subj);
    }
    else
    {
        return $e;
    }
}

sub ::fix_one(e,subj)
{
    if(undefined($subj))
    {
        warning('UNEXPECTED: undef');
        if($e = "he")
        {
            warning('UNEXPECTED: he');
            return "one";
        }
        else
        {
            warning('UNEXPECTED: sb else');
            return $e;
        }
    }

    if($e = "one")
        # 'ma przed sobą czas' => 'he has the time ahead of him'
        return inflect_personal_pronoun($subj->Num,
                                        $subj->Person,
                                        $subj->Gender,
                                        acc);

    if($e = "one's")
        # 'zawstydził swojego brata' => 'he put his brother to shame'
        return inflect_personal_pronoun($subj->Num,
                                        $subj->Person,
                                        $subj->Gender,
                                        gen);

    if($e = "oneself")
        # 'kobieta będąca na własnym garnuszku' => 'woman fending for herself'
        return inflect_reflexive_pronoun($subj->Num,
                                         $subj->Person,
                                         $subj->Gender);

    if($e = "he")
    {
        warning('UNEXPECTED: $e = "he"');
        return inflect_personal_pronoun($subj->Num,
                                        $subj->Person,
                                        $subj->Gender,
                                        nom);
    }

    return $e;
}

sub VP::surface()
{
    if(find("VPS","#"))
            return gensurface();

    fix_reflexive_pronouns();

    if(Question and %Interrog->label() != subject)
    {
        Inversion := 1;

        if($IPart := find("InterrogPart",) and
           ($IPart.Equiv = "whether" or
            $IPart.Equiv = "if"))
            delete($IPart,);
    }

    if(%Interrog and %Interrog->Prep and %Interrog->Prep != none
       and not parent()->cat() = "RelC")
    {
        insert_right("Prep",)->Equiv := strip_quotes(nounderscores(%Interrog->Prep));
        %Interrog->Prep := "";

        %Prep [ cat() = "Prep" ];
    }

    if(not Inversion and
       %Head and
       not %Head->is_aux_obligatory())
        %Head->WithAux := 0;
    else if(%Head)
    {
        %Head->WithAux := 1;

        $F := %Head->first_aux();
        if($F)
        {
            %Head->insert_before("AuxV",)->Equiv := nounderscores($F);
            %AuxV [ cat() = "AuxV" ];
        }

        $R := %Head->rest_aux();
        if($R)
        {
            %Head->insert_before("RestAuxV",)->Equiv := nounderscores($R);
            %RestAuxV [ cat() = "RestAuxV" ];
        }

        if(Prep)
        {
            %Head->insert_before("Prep",)->Equiv := nounderscores(Prep);
        }
    }

    order %AdvTime < %SubC;

    if(Inversion)
        order %AuxV < %Subject < %Disjunct < %Head;
    else
        order %Subject < %AuxV < %Disjunct < %RestAuxV < %Head;

    if(Tense = imperative and Person = 3 and %Subject)
    {
        %Subject->change_case(acc);
        order %AuxV < %Subject;
    }

    # 'kupił ten rower' p=>e 'he bought this bicycle'
    # 'kupił ten rower lub sprzedał ten samochód' p=>e 'he bought this bicycle or sold this car'
    # 'ten programista kupił, sprzedał lub grał' p=>e 'this programmer bought, sold or played'
    if((get_option(no_default_pronoun) and not parent()->parent()
        or (parent()->cat() = "CVP" or parent()->cat() = "VPS") and
            not is_first_VP()) and
       %Subject->Default and
       %Subject->Person = 3)
    {
        delete(%Subject,);
    }

    return gensurface();
}

sub VP::is_first_VP()
{
    if (not parent())
        return 1;

    if (parent()->cat() = "CVP")
        return parent()->is_first_VP();
    else if (parent()->cat() = "VPS")
        return parent()->first_subtree() = this() and parent()->is_first_VP();
    else
        return 1;
}

sub CVP::is_first_VP()
{
    return parent() and parent()->first_subtree() = this() and parent()->is_first_VP();
}

sub VPS::is_first_VP()
{
    return parent() and parent()->first_subtree() = this() and parent()->is_first_VP();
}

sub ::is_first_VP()
{
    return 0;
}

#
#

sub V::variant(model)
{
    if($model->Tense)
        Tense := $model->Tense;

    if($model->Person)
        Person := $model->Person;

    if($model->Num)
        Num := $model->Num;
}

#

#!!! TRACE czasownik.m


#

sub GNP::propagate(var, val)
{
    # 'ile potrzeba czasu' => 'how many the time is needed'
    set($var, $val);
    find(,"#")->propagate($var, $val);
}

sub GNPS::propagate(var, val)
{
    foreach $s
    {
        if($s->cat() = "GNP")
            # 'odwołanie lub zażalenie nie przysługuje' => 'it isn~t entitled to a cancellation or a complaint'
            $s->propagate($var, $val);
    }
}

sub ::propagate(var, val)
{
    set($var, $val);
}


#
sub ::set_dependent_speech()
{
    if (Tense = future)
    {
        # 'powiedział, że przyjedzie' => 'he said he would arrive'
        Tense := future_past;
    }
    else if (Tense = future_continuous)
    {
        # 'powiedział, że będzie przyjeżdżać' => 'he said he would be arriving'
        Tense := future_past_continuous;
    }
    else if (Tense = past or Tense = present_perfect)
    {
        # 'powiedział, że przyjechał' => 'he said he had arrived'
        Tense := past_perfect;
    }
    else if (Tense = past_continuous or Tense = present_perfect_continuous)
    {
        # 'poczuła, że popychano' => 'she felt that they had been pushing'
        Tense := past_perfect_continuous;
    }
    else if (Tense = present)
    {
        # 'powiedział, że chce pływać' => 'he said he wanted to swim'
        Tense := past;
    }
    else if (Tense = present_continuous)
    {
        # 'powiedział, że odpoczywa' => 'he said he was resting'
        Tense := past_continuous;
    }
}

sub SubC::dependent_speech()
{
    set_dependent_speech();
    find("VP",)->dependent_speech();
}

sub VPS::dependent_speech()
{
    # 'państwa nie notyfikowały Przewodniczącemu, że pragną uczestniczyć, zakłada się' => 'states didn~t notify for the Chairman, that want to participate, is betting'
    set_dependent_speech();
    foreach $I among %Component
    {
        warning('UNEXPECTED: foreach $I among %Component');
        $I->dependent_speech();
    }
}

sub CVP::dependent_speech()
{
    # 'opowiadał, że opiekował się' => 'he talked, that had looked after'
    %VP -> dependent_speech();
}

sub VP::dependent_speech()
{
    set_dependent_speech();
    %Head->dependent_speech();
}

sub V::dependent_speech()
{
    set_dependent_speech();
}

#

#

sub VPS::neg_as_none()
{
    foreach $I among %Component
    {
        $I->neg_as_none();
    }
}

sub CVP::neg_as_none()
{
    %VP->neg_as_none();
}

sub VP::neg_as_none()
{
    # 'nie chcę ani komputerów, ani drukarek, ani modemów' => 'I want neither computers, nor printers, nor modems'
    set_neg_as_none();
    %Head->neg_as_none();
}

sub V::neg_as_none()
{
    set_neg_as_none();
}

sub ::set_neg_as_none()
{
    Neg := 0;
}

#

sub VPS::perfect()
{
    warning('UNEXPECTED: czas.m - VPS::perf');
    foreach $I among %Component
    {
        $I->perfect();
    }
}

sub CVP::perfect()
{
    warning('UNEXPECTED: czas.m - CVP::perf');
    %VP->perfect();
}


sub VP::perfect()
{
    set_perfect();
    %Head->perfect();
}

sub V::perfect()
{
    set_perfect();
}

sub ::set_perfect()
{
   if(Tense = past)
       Tense := present_perfect;
}

#

sub VPS::continuous()
{
    warning('UNEXPECTED: czas.m - VPS::continuous');
    foreach $I among %Component
    {
        $I->continuous();
    }
}

sub CVP::continuous()
{
    warning('UNEXPECTED: czas.m - CVP::continuous');
    set_continuous();
    %VP->continuous();
}

sub VP::continuous()
{
    warning('UNEXPECTED: czas.m - VP::continuous');
    set_continuous();
    %Head->continuous();
}

sub V::continuous()
{
    warning('UNEXPECTED: czas.m - V::continuous');
    set_continuous();
}

sub ::set_continuous()
{
    warning('UNEXPECTED: czas.m - ::set_continuous');
    if(Tense = future)
        Tense := future_continuous;
    else if (Tense = future_past)
        Tense := future_past_continuous;
    else if (Tense = past)
        Tense := past_continuous;
    else if (Tense = present)
        Tense := present_continuous;
    else if (Tense = past_perfect)
        Tense := past_perfect_continuous;
}

#

sub VPS::simple()
{
    foreach $I among %Component
    {
        $I->simple();
    }
}

sub CVP::simple()
{
warning('UNEXPECTED: czas.m - CVP::simple');
    set_simple();
    %VP->simple();
}

sub VP::simple()
{
    set_simple();
    %Head->simple();
}

sub V::simple()
{
    # 'zawsze mówi prawdę' => 'he always tells the truth'
    set_simple();
}

sub ::set_simple()
{
    Tense := to_simple(Tense);
}

#

sub VPS::becondition()
{
    # 'tematy są widoczne dla społeczności, jeśli nie jesteś członkiem, nie możesz' => 'subjects are visible for the community, if you aren~t a member, you cannot'
    set_becondition();
    foreach $I
        $I->becondition();
}

sub CVP::becondition()
{
    set_becondition();
    %VP->becondition();
}

sub VP::becondition()
{
    set_becondition();
    find(,"#")->becondition();
    #%Head->becondition();
}

sub V::becondition()
{
    set_becondition();
}

sub ::set_becondition()
{
    # 'będę spać, kiedy przyjdziesz' => 'I will be sleeping, when you come'
    # 'będę na nią czekać, kiedy przyleci samolot' => 'I will be waiting for her, when a plane arrives'
    if(Tense = future)
        Tense := present;
    else if(Tense = future_continuous)
        # 'Te pliki będą w pełni dostępne tylko jeśli płyta będzie montowana w trybie UDF' => 'These files will only be truly available if the plate is being assembled under the UDF procedure'
        Tense := present_continuous;
    else if(Tense = conditional)
        # 'jeśli bym chciała to bym dostała' => 'if I wanted I would get'
        Tense := past;
    else if(Tense = conditional_perfect)
    {
        warning('UNEXPECTED: set_becondition - Tense = conditional_perfect');
        Tense := past_perfect;
    }
    else if(Tense = conditional_continuous)
    {
        warning('UNEXPECTED: set_becondition - Tense = conditional_continuous');
        Tense := past_continuous;
    }
    else if(Tense = conditional_perfect_continuous)
    {
        warning('UNEXPECTED: set_becondition - Tense = conditional_perfect_continuous');
        Tense := past_perfect_continuous;
    }
}

#

sub VPS::past()
{
    warning('UNEXPECTED: czas.m - VPS::past');
    foreach $I among %Component
    {
        $I->past();
    }
}

sub CVP::past()
{
    warning('UNEXPECTED: czas.m - CVP::past');
    set_past();
    %VP->past();
}

sub VP::past()
{
    warning('UNEXPECTED: czas.m - VP::past');
    set_past();
    %Head->past();
}

sub V::past()
{
    warning('UNEXPECTED: czas.m - V::past');
    set_past();
}

sub ::set_past()
{
    warning('UNEXPECTED: czas.m - ::set_past');
    if(Tense = present_perfect)
        Tense := past;
    else if(Tense = present_perfect_continuous)
        Tense := past_continuous;
    else if(Tense = conditional)
        Tense := conditional_perfect;
}

#

sub VP::set_tense(t)
{
    Tense := $t;
    find("V","#")->Tense := $t;
    if ($VPS := find("VPS",))
        # 'Możemy zacząć drukować plakaty i przygotowywać transparenty' => 'We can start printing posters and prepare banners'
        $VPS -> set_tense($t);
}

sub VPS:: set_tense(t)
{
    # 'umożliwi pozyskanie najemców zagranicznych i krajowych, a także stworzenie ośrodka odwiedzanego przez mieszkańców, którzy do tej pory byli' => 'he will enable to recruit foreign and domestic tenants, as well as to create the centre visited by residents which so far were'
    Tense := $t;
    foreach $VP
    {
      if ($VP->cat() = "VP" or $VP->cat() ="CVP")
          $VP->set_tense($t);
    }
}

sub CVP::set_tense(t)
{
    warning('UNEXPECTED: czas.m - CVP::set_tense');
    Tense := $t;
    find("VP",)->set_tense($t);
}

#

sub ::choose_pronoun(gnp, pron)
{
    if($h := $gnp->find("PersPron","#"))
    {
        # 'pomyślał o sobie' => 'he thought about himself'
        $pron->Num := $h->Num;
        $pron->Person := $h->Person;
        $pron->Gender := $h->Gender;
        $pron->S := $h->S;
    }
    else if($gnp->find("GNPS","#"))
    {
        # 'Akcjonariusze i programiści powinni posiadać przy sobie ten dokument.' => 'Shareholders and programmers should hold this document by themselves.'
        $pron->Num := 2;
        $pron->Person := 3;
    }
    else if($h := $gnp->find(,"#"))
    {
        if($h->Num = 2)
        {
            $pron->Num := 2;
            $pron->Person := 3;
        }
        else
        {
            $pron->Num := 1;
            $pron->Person := 3;

            if($h->eqv()->Rp)
            {
                if($h->eqv()->Rp = mo or ($h->eqv()->Rp = "mż" and $h.S = hum))
                {
                    # 'programista nie lubi samego siebie' => 'the programmer doesn~t like himself'
                    $pron->Gender := masc;
                }
                else if($h->eqv()->Rp = ż)
                {
                    if($h->S ^ hum)
                    {
                        # 'każda strona zastrzega sobie możliwość zmiany wyznaczonego przez nią' => 'every side is reserving the possibility of amending for itself appointed by her'
                        $pron->Gender := fem;
                    }
                    else
                    {
                        $pron->Gender := neut;
                    }
                }
                else
                {
                    # 'poziom głośności nagrań może się od siebie różnić' => 'the volume level of recordings can differ from itself'
                    $pron->Gender := neut;
                }
            }
            else
            {
                # 'nie każdy sobie pozwoli, żeby abonować ten dwutygodnik' => 'not everyone will let himself subscribe to this fortnightly magazine'
                $pron->Gender := masc_or_fem_or_neut;
            }
        }
    }
}

sub VPS::default()
{
    %Component [cat() = "VP" or cat() = "CVP"];
    $VP := find("VP",);

    if($VP->Tense = past or $VP->Tense = past_perfect or
       $VP->Tense = past_continuous or $VP->Tense = past_perfect_continuous)
    {
        # 'opowiadał, że przybył z Polski' => 'he talked, that had arrived from Poland'
        if ($CVP := find("CVP",) and $CVP->find("Conj",)->Equiv = that)
            $CVP->dependent_speech();
    }

    # 'zarówno śmiał się, jak i płakał' => 'both he laughed and cried'
    if(find("CVP",)->Nocomma)
        delete(',',);

#
#
#
#
#
#
#
#
}

sub ::move_compl_up(c,p)
{
    $L := $c->label();
    delete($c,);
    $p->insert_left($c,);
    $c->change_label($L);
}

sub ::is_heavy()
{
    return (3 < count_nodes());
}

sub VP::default()
{
    # 'Ile masz jabłek?' => 'How many apples do you have?'
    if(Question)
    {
        find("VPS",)->Question := 1;
        find("VPS",)->find("VP",)->Question := 1;
    }

    # 'zleciłem im, by pomalowali płot' => 'I commissioned them to paint the fence'
    # 'poleciłam im, by oczyścili i pomalowali płot' => 'I told them to clean and painted the fence'
    if(Type = "IN")
    {
        # 'nie mogę pisać' => 'I cannot write'
        set_tense(infinitive);
    }
    else if(Type = "TO")
    {
        # 'chcę umrzeć' => 'I want to die'
        set_tense(to_infinitive);
    }
    else if(Type = "GR")
    {
        # 'nie każdego stać na abonowanie tego dwutygodnika' => 'not everyone is capable of subscribing to this fortnightly magazine'
        set_tense(gerund);
    }

    %Subject [label() = subject];

    if((Tense = to_infinitive or Tense = infinitive or Tense = gerund)
       and %Subject)
    {
        # 'To jest przybycie ojca Laury' => 'It is Laura~s father arriving'
        %Subject->propagate("Case", acc);
    }

    %Head [cat() = "V" && label() = "#"];

    # 'potrzeba czasu' => 'a time is needed'
    if (%Head->precedes(%Subject) and Topicality != "q")
        %Subject->setDef(a, 50);

    %Oneself [cat() = "ReflPron" || find("ReflPron",) || (cat() = "Particle" && Equiv = "oneself") ];

    if(%Oneself)
    {
        # 'pomyśl o sobie' => 'think about yourself'
        if (%Oneself->cat() = "ReflPron")
        {
            # 'książka się czyta' => 'the book is reading itself'
            $for_change := %Oneself;
        }
        else if (%Oneself->cat() = "Particle")
        {
            # 'rozczarować siebie' => 'to disappoint oneself'
            delete(%Oneself,);
            $for_change := insert_right("ReflPron",);
        }
        else
        {
            $for_change := %Oneself->find("ReflPron",);
        }

        if(%Subject)
        {
            # 'pomyślał o sobie' => 'he thought about himself'
            choose_pronoun(%Subject, $for_change);
        }
        else if(parent() and parent()->cat() = "VP" and
                $psubj := parent()->find("GNP","subject"))
        {
            # 'Czy możesz sobie wyobrazić małżeństwo ze sklepikarzem?' => 'Can you for yourself depict the married couple with the shopkeeper?'
            choose_pronoun($psubj, $for_change);
        }
        else if(Tense = imperative)
        {
            $for_change->Num := %Head.Num;
            $for_change->Person := %Head.Person;
        }
    }

    %Adv [ cat() = "AdvP" || label() = "adv" ];


#
    %AdvLoc [cat() = "AdvP" && S = loc];
    %AdvTime [cat() = "AdvP" && S = time];

    # 'pomyśl o sobie' => 'think about yourself'
    if(%Subject or Tense = imperative)
        %Disjunct [cat() = "AdvP" && Disj];

    %Compl1 [label() = compl1];
    %Compl2 [label() = compl2];
    %Compl3 [label() = compl3];

    %SubC [(cat() = "SubC" || cat() = "VP" || cat() = "CVP") && label() != "adv"];

    # 'Adam ma kota' p=>e 'Adam has a cat'
    # 'Adam zabił kota' p=>e 'Adam killed the cat'
    if((%Head->Equiv = "be" or %Head->Equiv = "become" or %Head->Equiv = "have")
       and
       %Compl1->cat() = "GNP" and
       %Compl1->label() = "compl1")
    {
        %Compl1->setDef(a, 11);
    }

    # Zdanie podrzędne, które ma stać przed podmiotem przysłania inne
    # zdania podrzędne
    %PreSubjectSubC
            [cat() = "SubC" &&
             label() != compl1 && label() != compl2 && label() != compl3 &&
             precedes("Subject")];

    # Wyrażenia adverbialne, które powinny znaleźć się przed podmiotem
    %PreSubjectAdv [ not Disj && cat() = "Adv" && (S = time || Type = modul || precedes("Subject"))];

    #Question to początek zdania elementarnego pytającego lub podrzędnego

    # MW powinno być ..., bo w tym zdaniu Question jest true, a mimo to typ nie jest ustawiany
    # 'Ile masz jabłek?' => 'How many apples do you have?'
    %Question [Question = true];

    #Particle może być frazą z elementem "'one's"
    # 'ile potrzeba czasu' => 'how many the time is needed'
    %Particle [cat() = "Particle"];

    # 'kto się śmieje' => 'who is laughing'
    %Interrog [ Interrogative = 1];

    # 'krzyczał, piłem więc' => 'he screamed, so I drank'
    %Conj [ cat() = "Conj" && label() = "incorporated" ];

#

    # 'wcale mnie nie znasz' => 'you don~t know me at all'
    %FinalAtAll [ FinalAtAll ];

    order  %Conj < %PreSubjectClause < %Interrog < %Subject < %Disjunct < %Head < %Oneself    < %Particle < %Compl1 < %Compl2 < %Compl3 < %FinalAtAll < %SubC;

    # 'widziałem w sklepie Marka' => 'I could see Marek in the shop'
    # 'w sklepie widziałem Marka' => 'in the shop I could see Marek'
    if(%Compl1->cat() = "GNP" and
       not Compl1 = "NPf" and
       not (%Compl1->Prep and (%Compl1->Prep != none)) and
       not %Compl1->is_heavy())
    {
        order %Compl1 < %Particle;
    }

if(%Compl1 and (Compl1 = "NP" || Compl1 = "NPf" || Compl1 = "GR") and not %Compl1->Prep)
    {
        $compl := %Compl1;
        $head := %Head;
        %AdvIntra [ ((cat() = "GNP" && label() = "adv") || cat() = "AdvP")
                    && precedes($compl)
                    && $head->precedes(this())];
        order %Compl1 < %AdvIntra;
    }
if(%Compl2 and (Compl2 = "NP" || Compl2 = "NPf" || Compl2 = "GR") and not %Compl2->Prep)
    {
        $compl := %Compl2;
        $head := %Head;
        %AdvIntra [ ((cat() = "GNP" && label() = "adv") || cat() = "AdvP")
                    && precedes($compl)
                    && $head->precedes(this())];
        order %Compl2 < %AdvIntra;
    }

    # 'ile potrzeba czasu' => 'how many the time is needed'
    if(%Particle)
    {
        $part := %Particle;
        $head := %Head;

        %AdvIntra [ ((cat() = "GNP" && label() = "adv") || cat() = "AdvP")
                    && precedes($part)
                    && $head->precedes(this()) ];

        order %Particle < %AdvIntra;
    }

    # 'na dysku twardym są dokumenty tekstowe' => 'there are text documents on the hard disk'
    if(MoveAdvP)
        order %Compl1 < %Compl2 < %Compl3 < %Adv = %AdvLoc = %AdvTime;

    # różne modyfikacje

    # dopasowanie liczby czasownika do liczby podmiotu

    inherit("Num",);
    inherit("Person",);

    # 'chcieli wejść' => 'they wished accesses'
    if($subj:= find(,subject))
    {
        %Head.Num := $subj.Num;
        if($subj.Person and $subj.Person != nil)
        {
            # 'Poszłam na spacer.' => 'I went for a walk.'
            %Head.Person := $subj.Person;
        }
        else
        {
            # 'nie ci, którzy przyszli do kina' => 'not the ones which came to the cinema'
            %Head.Person := 3;
        }
        Num := %Head.Num;
        Person := %Head.Person;
    }

    foreach $s
    {
        if($s->Neg = 1 && $s->label() != "#")
        {
            # 'nie lubię ani Kamila, ani Karoliny' => 'I like neither Kamil, nor Karolina'
            neg_as_none();
        }
        if($s->cat() = "AdvP")
        {
            # 'będzie łatwo Markowi umrzeć' => 'it will be easy for Marek to die'
            if($s->S = tfreq)
            {
                # 'zawsze mówi prawdę' => 'he always tells the truth'
                simple();
                perfect();
            }

            if($s->S = time_continuous)
            {
                warining('MW $s->S = time_continuous');
                continuous();
            }
            if($s->S = tperf)
            {
                warning('UNEXPECTED: $s->S = tperf');
                perfect();
            }
        }
    }

    foreach $s
    {
        if($s->cat() = "AdvP" and $s->S = tpast)
        {
            warning('UNEXPECTED: $s->cat() = "AdvP" and $s->S = tpast');
            past();
        }
    }


#
    %AdvClause [cat() = "Adv" && find("SubC",)];

    # 'Kopernik udowodnił, że Ziemia obraca się wokół Słońca' => 'Kopernik proved, that the Earth revolves around the Sun'
    # 'zapytała czy pójdzie do szkoły' => 'she asked whether he would go to school'

    if(Tense = past or Tense = past_perfect or
       Tense = past_continuous or Tense = past_perfect_continuous)
    {
        if (%SubC.Type = ob or %SubC.Type = that or %SubC.Type = so_that)
        {
            # 'Zostawili adres, żeby wiedział gdzie są' => 'They left the address so that he knew where they are'
            %SubC->dependent_speech();
        }
        find("SubC",compl3)->dependent_speech();

        if ( (  $SubC := find("GNP", compl1)->find("SubC",) or
                $SubC := find("GNP", compl2)->find("SubC",) or
            $SubC := find("GNP", adv)->find("SubC",)
              )
              and $SubC->Type = that
           )
        {
            # 'wiedział o tym, że się spotkają' => 'he knew about the fact that they would meet'
            $SubC->dependent_speech();
        }

        # 'Pytał o to kiedy pójdzie do szkoły' => 'He asked about when he would go to school'
        if (    $SubC := find("GNP", compl1)->find("VP",) or
                $SubC := find("GNP", compl2)->find("VP",) or
            $SubC := find("GNP", adv)->find("VP",)
           )
        {
            $SubC->dependent_speech();
        }
    }

    # 'to jest to co chciałam kupić' => 'it is what I wanted to buy'
    if(%Interrog and %Interrog->Moved)
    {
        # zaimek pytajny z powrotem wyciągamy do zdania
        # nadrzędnego
        if(%Interrog->Moved = 1)
        {
            if(parent()->cat() = "VP")
            {
                move_compl_up(%Interrog, parent());
            }
        }
        else if(%Interrog->Moved = 2)
        {
            warning('UNEXPECTED: %Interrog->Moved = 2');
            if(parent()->cat() = "VP" and
               parent()->parent()->cat() = "VP")
            {
                warning('UNEXPECTED: parent()->cat() = "VP" and');
                move_compl_up(%Interrog, parent()->parent());
            }
        }
    }

    # 'umarłem czwartego września' => 'I died on September the fourth'
    if($D := find("GNP",adv) and
       $D->find(,day))
    {
        $D->Prep := "on";
    }

    $npi := null();
    $np := null();
if(Compl3 = "NPi" and find(,compl3))
        $npi := find(,compl3);

    if(Compl3 = "NP" and not Prep3 and find(,compl3))
        $np := find(,compl3);
if(Compl2 = "NPi" and find(,compl2))
        $npi := find(,compl2);

    if(Compl2 = "NP" and not Prep2 and find(,compl2))
        $np := find(,compl2);
if(Compl1 = "NPi" and find(,compl1))
        $npi := find(,compl1);

    if(Compl1 = "NP" and not Prep1 and find(,compl1))
        $np := find(,compl1);

    # obsługa NPi
    # 'dałem jej piłkę' => 'I gave her the ball'
    # 'dałem jej to' => 'I gave it to her'
    # 'dałem piłkę tej pięknej kobiecie' => 'I gave the ball to this beautiful woman'
    # 'dałem tej pięknej kobiecie piłkę' => 'I gave the ball to this beautiful woman'
    if($npi)
    {
        if($npi->cat() = "GNP" and $npi->find("PersPron","#"))
        {
            if(not $np or
               not $np->find(,"#")->cat() =~ /Pron/)
            {
                $npi->Clitic := 1;
                $npi->Prep := null();
            }
        }
    }

    %Clitic [Clitic];

    if(%Clitic)
    {
        order %Head < %Clitic < %Oneself < %Particle < %Compl1 < %Compl2 < %Compl3;

        %Compl1 [label() = compl1];
        %Compl2 [label() = compl2];
        %Compl3 [label() = compl3];
    }
    # -----------------------------------------------------------
}

sub CVP::default()
{
    # 'jeśli chodzi o pociągi, to mam o nich złe zdanie' => 'as for trains, I have a bad opinion about them'
    %Conj [ cat() = "Conj" ];
    %VP   [ cat() = "VP" ];

    if(%Conj->No_future)
    {
        # 'ubolewam nad tym, kiedy się spóźniam' => 'I am bemoaning it, when I am late'
        becondition();
    }

    foreach $conj
    {
        # 'nie lubię, kiedy się spóźniasz' => 'I am disliking, when you are late'
        if ($conj->cat() = "Conj" and $conj->No_future)
            becondition();
    }

    foreach $conj
    {
        if ($conj->cat() = "Conj" and $conj->No_negation)
        {
            # 'Zanim przeprowadzono badania na ludziach, działanie preparatu Mycamine zbadano w modelach eksperymentalnych' => 'Before they conducted research on people, the effect of Mycamine preparation was examined in breadboards'
            becondition();
            neg_as_none();
        }
    }

#
#
#
#
#
#
#
#
}

sub V::default()
{
    # 'musiałeś pojechać' => 'you had to go'
    if(Equiv = "must")
    {
        if(not Tense =~ /^present/)
        {
            # @todo nieladne
            Equiv := "have to";
            Aux := 0;
        }
    }
}


#!!! TRACE czasownik.t

#
#

#

#
#
#

#
#
#
#

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

#
#
#

#

#
#

#
#
#

#
#
#
#

#
#
#
#
#
#

#
#
#
#

#
#
#
#
#
#

#
#

#
#
#
#
#
#
#
#

#
#

#
#
#
sub ::convert_neg(n)
{
    # 'nie śmiał zapytać mnie o radę' => 'he didn~t dare to ask me about advice'
    if($n = oczekiwana)
        return null();

    # 'Monika nie poszła do szkoły' => 'Monika didn~t go to school'
    return $n;
}

sub ::is_neg_set(n)
{
    return not undefined(convert_neg($n));
}

#

sub ::set_be()
{
    # uproszczone sprawdzanie, powinno być
    # sprawdzenie czy "be" jest głową @todo

    # 'mieć czy być?' => 'to have or to be?'
    if(Equiv =~ /(^| )be( |$)/)
        Be := 1;
}

sub ::czas_to_tense(czas, aspekt)
{
    if(Be and not Cont)
    {
        warning('UNEXPECTED: czas_to_tense - Be and not Cont');
        Stat := 1;
    }

    if($czas = teraźniejszy)
    {
        if(get_option("use_shall1"))
        {
            warning('UNEXPECTED: czas_to_tense - shall');
            return future;
        }
        # 'jest pięknie' => 'it is beautifully'
        if($aspekt = dk)
            return present;

        # 'gram w grę' => 'I am playing the game'
        return present_continuous;
    }

    if($czas = "przyszły")
    {
        # 'pójdziemy na spacer' => 'we will go for a walk'
        if($aspekt = dk)
            return future;

        # 'będziemy śpiewać w chórze' => 'we will be singing in the choir'
        return future_continuous;
    }

    if($czas = "przeszły")
    {
#
        # 'nauczyła się czytać' => 'she learnt to read'
        if($aspekt = dk)
            return past;

        # @todo kiedy past_continuous????
        return past;
    }

    # 'wyraźnie napisany' => 'written clearly'
    if($czas = imiesłów_bierny)
        return past_participle;

    # 'wyraźnie piszący' => 'writing in a clear hand'
    if($czas = imiesłów_czynny)
        return gerund;

    # 'chodzić po górach' => 'to walk in the mountains'
    if($czas = bezokolicznik)
        return to_infinitive;

    # 'bycie niepowtarzalnym' => 'being unique'
    if($czas = odsłownik)
        return gerund;

    if($czas = bezosobnik)
    {
        # 'zrobiono obiad' => 'a dinner was made'
        # 'robiono obiad' => 'they were making lunch'
        if($aspekt = dk)
            return past;
        else
            return past_continuous;
    }

    # 'Zmywając naczynia, słuchała radia.' => 'Washing up, she listened to the radio.'
    if($czas = imiesłów_współczesny)
        return gerund;

    # 'Ubrawszy się, wybiegł szybko.' => 'Having get dressed, he ran out quickly.'
    if($czas = imiesłów_uprzedni)
        return gerund_perfect;

    # 'idź po książkę' => 'go for the book'
    if($czas = rozkazujący)
        return imperative;

    # 'poszłabyś ze mną do kina?' => 'would you go to the cinema with me?'
    if($czas = przypuszczający)
        return conditional;

    # 'Monika pracowała w biurze, a Michał jeździł do Poznania' => 'Monika worked in an office, and Michał went to Poznań'
    if(not $czas)
        return infinitive;

    warning("unknown value of C attribute: "+$czas);

    return infinitive;
}

sub ::to_simple(t)
{
    # 'Monika lubi Marka' => 'Monika likes Marek'
    if($t = present_continuous)
        return present;

    # 'chciano wejść' => 'they wished accesses'
    if($t = past_continuous)
        return past;

    # 'będzie trudno wygrać puchar' => 'it will be hard to win the cup'
    if($t = future_continuous)
        return future;

    if($t = future_past_continuous)
    {
        warning('UNEXPECTED: future_past_cont');
        return future_past;
    }

    if($t = present_perfect_continuous)
    {
        warning('UNEXPECTED: present_perf_cont');
        return present_perfect;
    }

    if($t = past_perfect_continuous)
    {
        warning('UNEXPECTED: past_perf_cont');
        return past_perfect;
    }
    if($t = conditional_continuous)
    {
        warning('UNEXPECTED: conditional_cont');
        return conditional;
    }
    if($t = conditional_perfect_continuous)
    {
        warning('UNEXPECTED: conditional_rerfect_cont');
        return conditional_perfect;
    }

    return $t;
}

C => V
{
    # etykieta 'posiłk' powinna pojawić się przy posiłkowej fukcji
    # czasowników 'być' i 'zostać' oraz przy partykułach 'by' i 'niech'
    # 'byście przyszli' => 'you would come'
    :posiłk => :aux {}

    # wstępne tłumaczenie zaimka 'się' i zaimka typu "samemu'
    '$się' => default_oneself {warning('UNEXPECTED: C - sie');}

    # wstępne tłumaczenie czasownika 'być' w funkcji posiłkowej
    # 'można będzie' => 'it will be possible'
    '$być':posiłk => 'be':aux {}

    #Wstępne tłumaczenie czasownika $zostać w funkcji posiłkowej
    # 'Marek został zaproszony' => 'Marek was invited'
    '$zostać':posiłk => 'be':aux {}

    #Wstępne tłumaczenie partykuły 'niech' w funkcji posiłkowej
    # 'niech przyjdą' => 'let them come'
    'niech' => 'let' {}

    #Wstępne tłumaczenie partykuły 'by' w funkcji posiłkowej
    # 'by pomógł mi' => 'he would help me'
    '$by'=> 'so that' {}

    Num := @.L;
    Person := @.O;

    Neg := convert_neg(@.Neg);
    S := @.S;

    # @attr A
    # @val dk - dokonany
    # @val ndk - niedokonany
    # 'poszedł do kościoła' => 'he went to the church'
    # 'szedł do kościoła' => 'he went to the church'
    if(@.A = dk)
        A := perf;
    else
        A := imperf;

    Tense := czas_to_tense(@.C, @.A);

    set_be();

    # 'nie wypada się śmiać' => 'it isn~t fitting to laugh'
    # 'ziemniaki są tanie' => 'potatoes are cheap'
    # 'będziesz czekała do jutra' => 'you will be waiting by tomorrow'
    if((Be or Aux or Can) and not Cont)
        Stat := 1;

    # z czasownika usuwana jest gałąź o słówku posiłkowym 'być'
    # 'będziemy śpiewać w chórze' => 'we will be singing in the choir'
    if((@.C = "przeszły" or @.C = bezokolicznik) and $BE := find('be',aux))
    {
        Num := $BE->eqv()->L;
        Person := $BE->eqv()->O;
        delete($BE,);
        Tense := future_continuous;
    }

    if(Tense = past_participle)
    {
        if($be := find('be',aux))
        {
            # 'tekst był wyraźnie napisany' => 'the text was written clearly'
            Num := $be->eqv()->L;
            Person := $be->eqv()->O;

            delete('be',aux);
            Voice := passive;
        }
    }

    # z czasownika usuwana jest gałąź o słówku posiłkowym 'niech'
    # 'niech mówi' => 'let him say'
    if((@.C = "przyszły" or @.C = teraźniejszy) and delete('let',aux))
        Tense := imperative;

    # z czasownika usuwana jest gałąź o słówku posiłkowym 'by'
    # 'by pomógł mi' => 'he would help me'
    if(@.C = "przeszły" and delete('so that',aux))
        Tense := conditional;

    # 'Monika lubi Marka' => 'Monika likes Marek'
    if(Stat or get_option(no_continuous))
        Tense := to_simple(Tense);

    # z czasownika usuwane są informacje o polskiej zwrotności

    # MW GNP jest dodawane do drzewa jako węzeł na tym samym poziomie co V
    # 'poradzi sobie' => 'he will advise himself'

    delete(oneself,);
    $GNP := find("GNP",);
    if($GNP->find("ReflPron",))
    {
        # 'wyobrażamy sobie, że ta chwila jest przed nami' => 'we are imagining that this moment is before us'
        delete($GNP,);
    }

#
    # usuwana jest gałąź z partykułą 'not'
    if(delete('not',))
    {
        warning('UNEXPECTED: delete(not)');
        if(not is_neg_set(Neg))
        {
            warning('UNEXPECTED: not is_neg_set(Neg)');
            Neg := 1;
        }
        else
            warning('UNEXPECTED: else not is_neg_set(Neg)');
    }

    if(Inflection =~ /^ *- (.*)$/)
    {
        # 'oznakowuje się' => 'they are mark'
        $rest := $1;

        if(Equiv =~ /^to (.*)$/)
        {
            warning('UNEXPECTED: Equiv =~ /^to (.*)$/');
            Equiv := $1;
            Inflection := $rest;
        }
    }
}

#

sub VP::move_compl(cmpl, level, real_cmpl_no)
{
    $L := compl + $real_cmpl_no;

    if($cmpl)
    {
        $NewVP := find("VP",);
        if($NewVP and $level = 2)
        {
            warning('UNEXPECTED: $NewVP and $level = 2');
            $NewVP := $NewVP->find("VP",);
        }

        $nc := $cmpl;
        delete($cmpl,);

        $nc->change_label($L);

        if($NewVP)
        {
            # 'rower chcę kupić' => 'I want to buy the bicycle'
            $NewVP->find(,"#")->insert_after($nc,);
            $nc->change_label(compl+$real_cmpl_no);

            $NewVP->cmpl_transfer($real_cmpl_no);

            $nc->Moved := $level;
        }
        else
            warning("can't find VP to move complementation");
    }
}

sub VP::cmpl_transfer(cmpl_no)
{
    $L := compl + $cmpl_no;
    $Prep :=  get("Prep" + $cmpl_no);
#

    if($COMPL := find(,$L))
    {
        if($COMPL.cat() = "GNP")
        {
            # 'rower chcę kupić' => 'I want to buy the bicycle'
            $COMPL.Prep := $Prep;
        }
        else if($COMPL.cat() = "AdvP")
        {
            warning('UNEXPECTED: $COMPL.cat() = "AdvP" 5');
            if(Compl2 = "AJ")
            {
                warning('UNEXPECTED: Compl2 = "AJ"');
                $COMPL.Adj := true;
            }
        }
        else if($COMPL.cat() = "SubC" or $COMPL = "VP")
        {
            warning('UNEXPECTED: $COMPL.cat() = "SubC" or $COMPL = "VP"');
            $Type := get("Type" + $cmpl_no);
            $COMPL.Type := $Type;
            $COMPL.Prep := $Prep;
        }
    }
}

#
#
#
#
#

#
sub V::find_particle()
{
    return find_particle_("");
}

#
#
sub V::find_particle_(p)
{
    # odcinamy od prawej
    if(Inflection =~ /^(.*[^ ]) +0 *$/)
    {
        Inflection := $1;

        if($found_particle := strip_one_word_from_equiv_($p))
            return $found_particle;
    }
    else if(not Inflection =~ /[^ ] [^ ]/)
    {
        if($found_particle := strip_one_word_from_equiv_($p))
        {
            warning("inflection ["+Inflection+"] does not match equiv [" + Equiv + "]");
            return $found_particle;
        }
    }

    if($p != "")
    {
        $created_particle := insert_after("Particle", );
        $created_particle->Equiv := $p;
        return $created_particle;
    }

    return null();
}

sub V::strip_one_word_from_equiv_(p)
{
    if(Equiv =~ /^(.*[^ ]) +([^ ]+) *$/)
    {
        Equiv := $1;

        if($p = "")
            return find_particle_($2);
        else
            return find_particle_($2 + " " + $p);
    }

    return null();
}


sub ::particle_hks(prt)
{
    $with_slots := pro_hks($prt);

    if($with_slots)
    {
        $prt->tfrags($prt->Equiv,1);
        $prt->clear("Equiv");
    }
}

FC => VP
{
    # 'błoto to nie jest nowość' => 'mud isn~t a novelty'
    :zbędny => :redundant {}

    delete('$być',redundant);

    # 'zawstydziła samą siebie' => 'she put oneself to shame'
    # 'bać się nocy' => 'to be afraid of a night'
    # 'rower chcę kupić, wyremontować i sprzedać' => 'I want to buy the bicycle, to refurnish and to sell'

:dop1 => :compl1
    {
        if(parent()->eqv()->Oblig1 = slot)
            change_label(slot1);
    }
:dop2 => :compl2
    {
        if(parent()->eqv()->Oblig2 = slot)
            change_label(slot2);
    }
:dop3 => :compl3
    {
        if(parent()->eqv()->Oblig3 = slot)
            change_label(slot3);
    }

    # 'Michał poszedł do pracy' => 'Michał went to work'
    :podmiot => :subject {}

    # etykieta 'czynne' powstaje przy zaimku 'się' w konstrukcjach
    # typu: 'buduje się domy'
    # 'buduje się domy' => 'houses are being built'
    :czynne => :active {}

    # etykieta 'bierne' powstaje przy zaimku 'się' w konstrukcjach
    # typu: 'książka się dobrze czyta'
    # 'książka się dobrze czyta' => 'the book well is reading itself'
    :bierne=>:passive {}

    :zwrotne=>:reflexive {warning('UNEXPECTED: FC - zwrotne');}
    # 'On nie zrobił tego zatem' => 'And so he didn~t do it'
    :inkorporacyjny=>:incorporated {}

    # wstępne tłumaczenie zaimka @się na default_oneself
    '$się' => default_oneself {warning('UNEXPECTED: FC - $się');}
    'się' => default_oneself {}

    # wstępne tłumaczenie partykuły 'to' w funkcji czasownika 'być'
    # 'dzisiaj komputery to nie nowość' => 'today computers aren~t a novelty'
    # 'komputer to maszyna do liczenia' => 'a computer is a machine for counting'
    'to'=> 'it_is' {}
    # 'oto twoje miejsce pracy' => 'it is your place of employment'
    # 'oto komputer Marka' => 'it is Marek~s computer'
    'oto'=> 'it_is' {}

    # wstępne tłumaczenie partykuły 'jest'
    # 'Dąb jest to drzewo' => 'An oak is a tree'
    # 'komputer jest to urządzenie do liczenia' => 'a computer is a device for counting'
    'jest'=> 'is' {}

    # wywalamy zbędne rzeczy z drzewa
    # 'komputer jest to urządzenie' => 'a computer is a device'
    if(find('it_is',))
    {
        delete('is',);
        delete('are',);
    }

    # wstępne tłumaczenie partykuły 'są'
    # 'kaczki są to ptaki' => 'ducks are birds'
    'są'=> 'are' {}

    # wstępne tłumaczenie partykuły 'nie'
    'nie' => 'not' {}

    delete(',',prerel);

    # tłumaczenie przysłówków oznaczonych jako "modal" (np. 'trudno', 'łatwo')
    # 'łatwo było płakać' => 'it was easy to cry'
    # 'będzie łatwo Markowi umrzeć' => 'it will be easy for Marek to die'
    if($ma := find("AdvP","#"))
    {
        $ma->change_label("modal");

        $vh := $ma->insert_before("V","#");

        $vh->Equiv := "be";
        $vh->Be := 1;
        $vh->Inflection := "V!";
        $vh->SpecPrep := "it";
        $vh->Stat := 1;

$vh->Compl1 := $ma->Compl1;
        $vh->Prep1 := $ma->Prep1;
        $vh->Def1 := $ma->Def1;
$vh->Compl2 := $ma->Compl2;
        $vh->Prep2 := $ma->Prep2;
        $vh->Def2 := $ma->Def2;
        # musimy przestawić indeksy, bo frazy czasownikowe wymagają niektórych
        # dopełnień jako Dop3, a nie Dop2
        $vh->Compl3 := $ma->Compl2;
    }

    %Head [ label() = "#" ];
    $H := %Head;

    # poprawianie negacji dla fraz
    # 'nie przybijam młotkiem tej deski' => 'I am not nailing this board'
    # 'nie pójdziesz do szkoły' => 'you won~t go to school'
    if(is_neg_set(@.Neg) and @.Hk)
        %Head->Neg := 1;

    # najpierw poprawiamy umiejscowienie dopełnień w zdaniach
    # typu 'rower chcę kupić'

    if(@.Ps1)
    {
        if(@.Ps1 =~ /^podczasownik(.*)/)
        {
            # 'z których możesz wybrać węzły do których chcesz dodać' => 'which you can withdraw knots to which you want to add from'
            move_compl(find(,compl1),1,$1);
        }
        else if(@.Ps1 =~ /^podpodczasownik(.*)/)
        {
            warning('UNEXPECTED: @.Ps1 =~ /^podpodczasownik(.*)/');
            move_compl(find(,compl1),2,$1);
        }
    }


    if(@.Ps2)
    {
        if(@.Ps2 =~ /^podczasownik(.*)/)
        {
            # 'opowiadał, że kwiaty trzeba podlać' => 'he talked, that it was necessary to water flowers'
            # 'rower chcę kupić' => 'I want to buy the bicycle'
            move_compl(find(,compl2),1,$1);
        }
        else if(@.Ps2 =~ /^podpodczasownik(.*)/)
        {
            warning('UNEXPECTED: @.Ps2 =~ /^podpodczasownik(.*)/');
            move_compl(find(,compl2),2,$1);
        }
    }

    if(@.Ps3)
    {
        if(@.Ps3 =~ /^podczasownik(.*)/)
        {
            warning('UNEXPECTED: @.Ps3 =~ /^podczasownik(.*)/');
            move_compl(find(,compl3),1,$1);
        }
        else if(@.Ps3 = /^podpodczasownik(.*)/)
        {
            warning('UNEXPECTED: @.Ps3 = /^podpodczasownik(.*)/');
            move_compl(find(,compl3),2,$1);
        }
    }

    # poprawianie osoby (np. "bym kupił samochód")
    # 'bym kupiła samochód' => 'I would buy the car'
    if($H->cat() = "V" and (@.O = 1 or @.O = 2)
       and @.O != $H->eqv()->O)
        $H->Person := @.O;

    if(parent() and parent()->cat() = "CVP" and $H->cat() = "V" and
       $cnj := parent()->find("Conj",) and
       ($cnj->Person = 1 or $cnj->Person = 2))
    {
        # 'obyś go polubił' => 'so that you get to like him'
        $H->Person := $cnj->Person;
    }

    if(find('it_is',))
    {
        # 'to jest to co chciałam kupić' => 'it is what I wanted to buy'
        delete('it_is',);
        $v := insert_left("V","#");
        %Head [ label() = "#" ];
        $v->Equiv := "be";

        $v->Be := 1;
        $v->Stat := 1;

        if(not find(,subject))
        {
            $s := insert_left("DemonsPron",subject);
            $s->Num := 1;
            $s->Equiv := "it";

            if(find(,compl1)->Num = 2)
            {
                # 'to są te komputery, które chciałam kupić' => 'these are these computers which I wanted to buy'
                $s->Num := 2;
                $s->Equiv := "these";
            }
        }
    }

    # 'kto złapie piłkę?' => 'who will catch the ball?'
    %Interrog [Interrogative = 1];

    if(%Interrog)
        Topicality := "q";

    # 'w pokoiku jest krzesło' => 'there is a chair in the room'
    # 'w pokoiku są krzesła' => 'there are chairs in the room'
    # 'jest radość' => 'there is joy'
    # 'czy w pokoiku są meble?' => 'is there furniture in the room?'
    # 'jest człowiek w sklepie' => 'there is a man in the shop'
    # 'w sklepie jest człowiek' => 'there is a man in the shop'
    # 'czy jest książka?' => 'is there a book?'
    if(%Head->eqv()->cat() = "C" and
       %Head->eqv()->label() != zbędny and
       (%Head->eqv()->find('$być',"#") or %Head->eqv()->find('$będę',"#")) and
       %Head->Person = 3 and
       not eqv()->find('nie',) and
       not find(,"compl1") and
       not find(,"compl2") and
       not find(,"compl3") and
       (Topicality != q or %Interrog->Equiv = "whether") and
       %Head->precedes($psubj := find(,"subject")) and
       not $psubj->find("AdjPron",)->Equiv = "this" and
       ($psubj->setDef(a,30) or $psubj->U))
    {
        $psubj->change_label(compl1);

        $there := %Head->insert_before('there',subject);
        $there->Person := 3;
        $there->Num := $psubj->Num;

        MoveAdvP := 1;
    }

    # 'nie ma soli' => 'there is no salt'
    if(eqv()->find('nie',) and
       (eqv()->find('ma',) or (eqv()->find('$być',) and eqv()->find('$być',)->label() != zbędny or eqv()->find('$będę',)) and find(,compl1)))
    {
        delete('ma',);
        delete('$być',);
        delete('$będę',);
        #insert_left('no',);
        $v := insert_left("V","#");
        %Head [ label() = "#" ];
        $v->Equiv := "be";

        $v->Be := 1;
        $v->Stat := 1;

        $v->Num := find(,compl1)->Num;
        $v->Tense := czas_to_tense(eqv()->C, ndk);
        if ($subj:= find("GNP",) and $subj.Interrogative = 1)
        {
            # 'u kogo nie ma wody?' => 'who is water missing?'
            $subj->change_label(subject);
            $subj->change_case(nom);
            $subj->Prep := none;
            $v.Person := $subj.Person;
            $v->Neg := 0;
            #delete('no',);
            $v->Equiv := "be missing";
        }
        else if (eqv()->find(,"dop1")->S ^ anim)
        {
            # 'już go nie ma' => 'it isn~t already'
            $subj:= find(,compl1)->change_label(subject);
            $subj->change_case(nom);
            $subj->Prep := none;
            $v->Neg := 1;
            $v.Person := $subj.Person;
            #delete('no',);
        }
        else
        {
            $v->Neg := 0;
            $v->Person := 3;
            $th := insert_left('there',subject);
            if ($compl1 := find(,compl1))
            {
                if ($no := $compl1->find("AdjPron",) and $no->Equiv = "no")
                {
                    # 'nie ma żadnego samochodu' => 'there is no car'
                }
                else
                {
                    $compl1->insert_left('no',);
                    $compl1->setDef(zero, 100);
                }
            }
            else
            {
                # 'nie ma w tej kwestii' => 'there is in this issue no'
                $v->Num := 1;
                insert_right('no',);
            }
            $th.Num := $v.Num;
        }
    }

    # Zdania typu "jest pięknie"
    # 'dzisiaj jest pięknie' => 'it is today beautifully'
    if (($be:= find('$być',) or $be:= find('$będę',))
        and not(find(,compl1)))
    {
        $v := insert_left("V","#");
        $v->Equiv := "be";

        $v->Be := 1;
        $v->Stat := 1;

        $v->Tense := czas_to_tense($be->eqv()->C, dk);
        if (eqv()->find('nie',))
            # 'nie było aż tak trudno oszukać ich' => 'it wasn~t so hard to cheat them'
            $v->Neg := 1;

        delete($be,);
        foreach $A {if ($A->cat() = "AdvP") {$A->Adj := true;}}
        if(not find(,subject))
        {
            $s := insert_left("DemonsPron",subject);
            $s->Num := 1;
            $s->Equiv := "it";
        }
    }

    if(undefined(Inflection))
        Inflection := "V1";

    Question := @.Pytanie;

    # trzeba uwzględnić (rzadki) przypadek, gdy w polu englishSyntax
    # wpisano Neg
    if(%Head and is_neg_set(%Head->Neg))
    {
        Neg := convert_neg(%Head->Neg);
        delete('not',);
    }
    else if(delete('not',))
    {
        # 'nie będę szczęśliwa' => 'I won~t be happy'
        Neg := 1;

        if(%Head)
            %Head->Neg := 1;
    }

    # 'krzesło jest w pokoiku' => 'the chair is in the room'
    # 'w domu jest Adam' => 'Adam is at home'
    # 'w domu jestem' => 'I am at home'
    # 'w domu jest on' => 'he is at home'
    # 'jest ten człowiek w sklepie' => 'this man is in the shop'
    # 'krzesło jest zielone' => 'the chair is green'
    # 'analfabetą muzycznym jest słoń' => 'an elephant is musically illiterate'
    # 'gdzie jest książka? => 'where is the book?'
    # 'prosiła o pomoc' => 'she called for help'

    if(%Head)
    {
        %Head->Tense := czas_to_tense(@.C, @.A);

        if(%Head->Inflection = "VBE" or %Head->Stat or get_option(no_continuous))
            %Head->Tense := to_simple(%Head->Tense);

        Tense := %Head->Tense;

        if(%Head->cat() = "V")
        {
            # "Particle" to nieodmienna cząstka która idzie po dopełnieniu
            if(%Head->Equiv =~ /^([^ ]+) (.*)$/)
            {
                if(! %Head->Inflection or %Head->Inflection = "")
                {
                    %Head->Equiv := $1;

                    $npart := %Head->insert_after("Particle", );
                    $npart->Equiv := $2;
                    particle_hks($npart);
                }
                else
                {
                    $npart := %Head->find_particle();
                    particle_hks($npart);
                }
            }

            Refl := %Head->Refl;
            SpecPrep := %Head->SpecPrep;
            SpecCat := %Head->SpecCat;
            SpecDef := %Head->SpecDef;
        }

        # 'staram się o książkę' => 'I am trying the book to get'
        # 'zazdroszczę Ci cierpliwości' => 'I am envying you the patience'
        # 'nie śmiał zapytać mnie o radę' => 'he didn~t dare to ask me about advice'

if(undefined(Compl1) and %Head->Compl1)
        {
            Compl1 := %Head->Compl1;
            Prep1  := %Head->Prep1;
            Def1   := %Head->Def1;
        }
if(undefined(Compl2) and %Head->Compl2)
        {
            Compl2 := %Head->Compl2;
            Prep2  := %Head->Prep2;
            Def2   := %Head->Def2;
        }
if(undefined(Compl3) and %Head->Compl3)
        {
            Compl3 := %Head->Compl3;
            Prep3  := %Head->Prep3;
            Def3   := %Head->Def3;
        }
    }
    else
    {
        Tense := czas_to_tense(@.C, @.A);

        set_be();

        if(Be and not Cont)
        {
            warning('UNEXPECTED: Be and not Cont');
            Stat := 1;
        }
        if(Stat or get_option(no_continuous))
        {
            warning('UNEXPECTED: Stat or get_option(no_continuous)');
            Tense := to_simple(Tense);
        }
    }

    # dołączana jest gałąź ze zwrotnością
    if(Refl)
    {
        warning('UNEXPECTED: zwrotność');
        insert_right("ReflPron",);
    }
    # jeśli czasownik we frazie czasownikowej ma czas 'unknown'
    # (tak jest na przykład w stronie biernej), to informacje o
    # czasie trzeba zaczerpnąć ze zdania polskiego

#
    if(Tense = unknown)
    {
        warning('UNEXPECTED: VP - tense = unknown');
        if(@.C = teraźn)
            Tense := present;
        else if(@.C = "przyszły")
            Tense := "future";
        else if(@.C = "przeszły")
            Tense := "past";
    }


#

    if(not find(,subject) and not find("VPS",))
    {
        # Transfer konstrukcji z 'się' czynnym.

        # W części syntezy morfologicznej trzeba zwrócić uwagę, że w stronie
        # biernej istotny jest aspekt czasownika,to znaczy, by dla aspektu
        # 'imperf' dodawać cząstkę 'being'.

        if(find(default_oneself,active))
        {
            delete(default_oneself,active);

            if (@.Dop1 = bier and @.Przyim1 = brak)
            {
                # 'buduje się domy' => 'houses are being built'
                # 'budzi się astronomów' => 'astronomers are being woken up'
                find(,compl1)->change_case(nom);
                find(,compl1)->Prep := none;
                find(,compl1)->change_label(subject);
                Voice := passive;
                %Head->Voice := passive;
            }
            else if (@.Dop2 = bier and @.Przyim2 = brak)
            {
                # 'dokumenty odsyła się Trybunałowi' => 'documents are being sent back to the Tribunal'
                find(,compl2)->change_case(nom);
                find(,compl2)->Prep := none;
                find(,compl2)->change_label(subject);
                Voice := passive;
                %Head->Voice := passive;
            }
            else if (@.Dop3 = bier and @.Przyim3 = brak)
            {
                warning('UNEXPECTED: else - else if 3 - @.Dop3 = bier and @.Przyim3 = brak');
                find(,compl3)->change_case(nom);
                find(,compl3)->Prep := none;
                find(,compl3)->change_label(subject);
                Voice := passive;
                %Head->Voice := passive;
            }
            else
            {
		        # 'mówi się o Adamie' => 'they are talking about Adam'
                $PersPron := insert_left("PersPron", subject);
                $PersPron.Person := 3;
                $PersPron.Num := 2;
                $PersPron.Case := nom;
                Num := 2;
            }
        }
        else if(@.C = bezosobnik)
        {
            if (@.Dop1 = bier and @.Przyim1 = brak)
            {
                # 'wybrano prezydenta' => 'a president was chosen'
                find(,compl1)->change_case(nom);
                find(,compl1)->Prep := none;
                find(,compl1)->change_label(subject);
                Voice := passive;
                %Head->Voice := passive;
                Tense := past;
                Num := find(,subject)->Num;
            }
            else if (@.Dop2 = bier and @.Przyim2 = brak)
            {
                # 'właściwość do rozstrzygnięcia przyznano Trybunałowi' => 'the property for the decision was granted the Tribunal'
                find(,compl2)->change_case(nom);
                find(,compl2)->Prep := none;
                find(,compl2)->change_label(subject);
                Voice := passive;
                %Head->Voice := passive;
                Tense := past;
                Num := find(,subject)->Num;
            }
            else if (@.Dop3 = bier and @.Przyim3 = brak)
            {
                warning('UNEXPECTED: else else if 4 - @.Dop3 = bier and @.Przyim3 = brak');
                find(,compl3)->change_case(nom);
                find(,compl3)->Prep := none;
                find(,compl3)->change_label(subject);
                Voice := passive;
                %Head->Voice := passive;
                Tense := past;
                Num := find(,subject)->Num;
            }
            else
            {
                # 'dbano o książki' => 'they were caring about books'
                $THEY := insert_default_subject(2,3,person,masc);
                Tense := past;
                Num := 2;
            }
        }
        else if(SpecPrep = it)
        {
            # 'powiedział, że kwiaty trzeba podlać' => 'he said it was necessary to water flowers'
            $IT := insert_default_subject(1, 3, abstr, neut);
            $IT->Default := 0;
        }
        else if(SpecPrep = one or SpecPrep = there)
        {
            # 'niepodobna śmiać się' => 'one can~t laugh'
            $IT := insert_default_subject(1, 3, abstr, neut);
            $IT->Equiv := SpecPrep;
            $IT->Default := 0;
        }
        else if(SpecCat = "0" or @.Podmiot = brak)
        {
            # 'rozchmurz się' => 'brighten up'
            if($COMPL := find(,compl1) and Compl1 = "SUBJ")
            {
                # 'potrzeba czasu' => 'a time is needed'
                $COMPL->change_label(subject);
            }
            else if($COMPL := find(,compl2) and Compl2 = "SUBJ")
            {
                warning('UNEXPECTED: $COMPL := find(,compl2) and Compl2 = "SUBJ"');
                $COMPL->change_label(subject);
            }
            else if($COMPL := find(,compl3) and Compl3 = "SUBJ")
            {
                warning('UNEXPECTED: $COMPL := find(,compl3) and Compl3 = "SUBJ"');
                $COMPL->change_label(subject);
            }

            if($COMPL)
            {
                # 'potrzeba czasu' => 'a time is needed'
                $COMPL->Prep := none;
                $COMPL->propagate("Case", nom);
            }
        }
#
        else
        {
            if( SpecCat != "0" and %Head and
                not ((Tense = imperative and %Head->Person != 3) or
                    Tense = infinitive or Tense = to_infinitive or
                    Tense = past_participle or Tense = gerund or
                    Tense = gerund_perfect))
            {
                $dsubj := insert_default_subject(%Head->Num, %Head->Person, %Head->S, @.R);

                # 'zielony byłam czerwona' => 'green I was red'
                # 'zielony były czerwone' => 'green were red'
                # 'były czerwone' => 'they were red'
                if(%Head->Person = 3)
                    $dsubj->Default := 1;
            }
        }
    }

    # przechodzenie podmiotu na dopełnienie i vice versa
    if(SpecCat = "NP"  || SpecCat = "NPf")
    {
        $subj := find(,subject);

        if($COMPL := find(,compl1) and Compl1 = "SUBJ")
        {
            # 'wcale mi się nie podobasz' p=>e 'I don~t like you at all'
            $subj->change_label(compl1);
            $subj->propagate("Case", acc);
            $COMPL->change_label(subject);
            $COMPL->propagate("Case", nom);
            $COMPL->Prep := none;
            Compl1 := SpecCat; Prep1 := SpecPrep; Def1 := SpecDef;
        }
        else if($COMPL := find(,compl2) and Compl2 = "SUBJ")
        {
            warning('UNEXPECTED: $COMPL := find(,compl2) and Compl2 = "SUBJ"');
            $subj->change_label(compl2);
            $subj->propagate("Case", acc);
            $COMPL->change_label(subject);
            $COMPL->propagate("Case", nom);
            $COMPL->Prep := none;
            Compl2 := SpecCat; Prep2 := SpecPrep; Def2 := SpecDef;
        }
        else if($COMPL := find(,compl3) and Compl3 = "SUBJ")
        {
            warning('UNEXPECTED: $COMPL := find(,compl3) and Compl3 = "SUBJ"');
            $subj->change_label(compl3);
            $subj->propagate("Case", acc);
            $COMPL->change_label(subject);
            $COMPL->propagate("Case", nom);
            $COMPL->Prep := none;
            Compl3 := SpecCat; Prep3 := SpecPrep; Def3 := SpecDef;
        }
        else if(not find(,compl1))
        {
            # 'Uprawnionemu z Gwarancji przysługuje prawo do wymiany' => 'Authorised from the Guarantee is entitled to a right to the exchange'
            $subj->change_label(compl1);
            $subj->propagate("Case", acc);
            Compl1 := SpecCat; Prep1 := SpecPrep; Def1 := SpecDef;
            insert_default_subject(1, 3, abstr, neut);
        }
        else if(not find(,compl2))
        {
            warning('UNEXPECTED: not find(,compl2)');
            $subj->change_label(compl2);
            $subj->propagate("Case", acc);
            Compl2 := SpecCat; Prep2 := SpecPrep; Def2 := SpecDef;
            insert_default_subject(1, 3, abstr, neut);
        }
        else if(not find(,compl3))
        {
            warning('UNEXPECTED: not find(,compl3)');
            $subj->change_label(compl3);
            $subj->propagate("Case", acc);
            Compl3 := SpecCat; Prep3 := SpecPrep; Def3 := SpecDef;
            insert_default_subject(1, 3, abstr, neut);
        }
    }


    # Transfer konstrukcji 'Książka się dobrze czyta'
    #    'Oni się szukali'
#
    # 'książka się czyta' => 'the book is reading itself'
    if(find(default_oneself,passive))
    {
        delete(default_oneself,passive);
        if (eqv()->S < "con" or eqv()->S < "ab" or eqv()->S = "-hum") # "-hum" ze względu na zaimki
        {
            warning('UNEXPECTED: eqv()->S < "con" or eqv()->S');
            Voice := passive;
            %Head->Voice := passive;
        }
        else
            insert_right("ReflPron",);
    }

    #Transfer podmiotu w przypadku, gdy podmiot zawiera zdanie podrzędne, np. 'To, kiedy przyjdzie, nie jest jasne'.
    #Pożądane zdanie docelowe: 'It is not clear when he will come'.

    $SUBJECT := find(,subject);
    $SUBJECT_TEMP := $SUBJECT;

#
#
#
#
#

    if($SUBJECT->find("SubC", "#"))
    {
        warning('UNEXPECTED: VP - $SUBJECT->find("SubC", "#")');
        delete($SUBJECT,);
        $IT := insert_left("PersPron",subject);
        $IT.Num :=1;
        $IT.Gender := neut;
        $IT.Person := 3;
        insert_right($SUBJECT_TEMP,);
    }

    ## transfer dopełnień

    if($COMPL := find(,compl1))
    {
        if($COMPL.cat() = "GNP")
        {
            # 'Lubię to, co ty' => 'I like it, as you'
            # 'Myślę o tym, że przyjdziesz' => 'I am thinking about the fact that you will come'

            $COMPL.Prep := Prep1;
            #Jeśli frazą rzeczownikową bedącą dopełnieniem jest zdanie podrzędne (np. Lubię to, co ty, Myślę o tym, że przyjdziesz)
            #to jeśli po stronie angielskiej NP jest poprzedzona 'Prep', to zamieniamy zdanie podrzędne na 'gerund'
            #Otrzymamy 'I like what you like', ale 'I am thinking of your coming'
            if ($COMPL->find("SubC", "#"))
            {
#
                warning('UNEXPECTED: VP - $COMPL->find("SubC", "#")');
                if ($COMPL.Prep != '' and SubC.Type != ob)
                {
                    SubC.Type := gerund;
                }
#
            }
        }
        #Zamiana przysłówka na przymiotnik, np 'Dobrze wyglądasz'. Przy syntezie morfologicznej trzeba o tym pamiętać,
        #by sprawdzić, czy przysłówek odprzymiotnikowy nie ma ustawionego atrybutu Adj = true

        # 'Monika, będąca najstarszą z sióstr, poszła do szkoły' => 'Monika, being oldest of sisters, went to school'
        if($COMPL.cat() = "AP")
            $COMPL.Prep := Prep1;

        if($COMPL.cat() = "AdvP")
        {
            # 'zapisać się zarówno na balet jak i na koszykówkę' => 'to enrol both for the ballet and for the basketball'
            if(Compl1 = "AJ")
            {
                warning('UNEXPECTED: Compl1 = "AJ"');
                $COMPL.Adj := true;
            }
        }

#
        if($COMPL.cat() = "SubC" or $COMPL.cat() = "VP")
        {
            warning('UNEXPECTED: $COMPL.cat() = "SubC" or $COMPL.cat() = "VP"    1');
            $COMPL.Type := Compl1;
            $COMPL.Prep := Prep1;
        }
    }

    if($COMPL := find(,compl2))
    {
        # 'prosiła mnie o zadanie' => 'she asked me for the task'
        if($COMPL.cat() = "GNP")
            $COMPL.Prep := Prep2;

        if($COMPL.cat() = "AdvP")
        {
            warning('UNEXPECTED: $COMPL.cat() = "AdvP" 3');
            if(Compl2 = "AJ")
            {
                warning('UNEXPECTED: Compl2 = "AJ"');
                $COMPL.Adj := true;
            }
        }

        # 'poprosiła o przyniesienie okularów' => 'she asked to bring glasses'
        if($COMPL.cat() = "SubC" or $COMPL.cat() = "VP")
        {
            $COMPL.delete("Prep",);

            $COMPL.Type := Compl2;
            $COMPL.Prep := Prep2;
        }
    }

    if($COMPL := find(,compl3))
    {
        # 'przygważdża się Marka do podłogi bagnetem' => 'Marek is being pinned to the floor with the bayonet'
        if($COMPL.cat() = "GNP")
            $COMPL.Prep := Prep3;

        if($COMPL.cat() = "AdvP")
        {
            warning('UNEXPECTED: $COMPL.cat() = "AdvP" 4');
            if(Compl3 = "AJ")
            {
                warning('UNEXPECTED: Compl3 = "AJ"');
                $COMPL.Adj := true;
            }
        }

        # 'opowiadał, że kwiaty trzeba podlać' => 'he talked, that it was necessary to water flowers'
        if($COMPL.cat() = "SubC" or $COMPL.cat() = "VP")
        {
            $COMPL.Type := Compl3;
            $COMPL.Prep := Prep3;
        }
    }

    if(Tense = imperative)
    {
        # wywalamy "you" (od "pan", "pani")
        # 'niech pan skręci!' => 'turn!'
        if($pp := find("GNP",subject)->find("PersPron","#"))
        {
            if(find("GNP",subject)->only_son($pp) and
               $pp->Person = 2)
            {
                delete("GNP",subject);
                Person := 2;
                %Head->Person := 2;
            }
        }
    }
}

sub ::insert_default_subject(num, person, sem, rodzaj)
{
    if(not find("GNP",subject))
    {
        $subj := %Head->insert_before("GNP",subject);

        $PersPron := $subj->insert_left("PersPron", "#");
        $PersPron.Num := $num;
        $PersPron.Person := $person;
        $PersPron.Case := nom;

        if($num = 1 and $person = 3)
        {
            if($rodzaj = nil)
            {
                if($sem < hum)
                {
                    # 'nie jedzie' => 'he/she isn~t going'
                    $PersPron.S := hum;
                    $PersPron.Gender := masc_or_fem;
                }
                else
                {
                    # 'powiedział, że go nie lubi' => 'he said he didn~t like it'
                    $PersPron.Gender := masc_or_fem_or_neut;
                }
            }
            else if($rodzaj = "mnż" or $rodzaj = "mż" or $rodzaj = "mo")
            {
                if($sem < hum)
                {
                    # 'poszedł w nocy' => 'he went at night'
                    $PersPron.S := hum;
                    $PersPron.Gender := masc;
                }
                else
                {
                    # 'nie chciał się śmiać' => 'he didn~t want to laugh'
                    $PersPron.Gender := masc_or_neut;
                }
            }
            else if($rodzaj = ż)
            {
                if($sem < hum)
                {
                    # 'wyszła po mleko' => 'she left for the milk'
                    $PersPron.S := hum;
                    $PersPron.Gender := fem;
                }
                else
                {
                    # 'nie chciała się śmiać' => 'she didn~t want to laugh'
                    $PersPron.Gender := fem_or_neut;
                }
            }
            else
            {
                # 'niepodobna śmiać się' => 'one can~t laugh'
                $PersPron.Gender := neut;
            }
        }
        else if($num = 2 and $person = 3)
        {
            # 'dbano o książki' => 'they were caring about books'
            $PersPron.S := any;
        }
        else
        {
            # 'zielony byłam czerwona' => 'green I was red'
            $PersPron.S := hum;
        }

        $subj.Num := $PersPron.Num;
        $subj.Person := $PersPron.Person;
        $subj.Case := $PersPron.Case;
        $subj.Gender := $PersPron.Gender;
        $subj.S := $PersPron.S;

        # 'było czerwone' => 'it was red'
        if($subj.Num = 1 and $subj.Person = 3)
            $subj.Default := 1;

        return $subj;
    }

    return 0;
}

#


#!!! TRACE liczebnik.t

#

LP => OrdNum
{
    # 'na trzecim miejscu' => 'on the third place'
    Def := the;
}

LG => CardNum
{
    # 'jeden za wszystkich' => 'one for everyone'
    # 'trzej muszkieterowie' => 'three musketeers'
    # 'ile kupisz jabłek' => 'how many apples you will buy'
    '$jeden'=>'one' {}
    if (find('one',"#"))
        Equiv := "one";

    'jedno' => 'one' {warning('UNEXPECTED: LG - jedno');}

    '$zero'=>'zero' {}
    if (find('zero',"#"))
        Equiv := "zero";

#
    'dużo'=>'how many' {warning('UNEXPECTED: LG - dużo');}
    if (find('how many',"#"))
    {
        warning('UNEXPECTED: LG - find(how many,"#")');
        Equiv := "how many";
    }

    if (eqv()->find('$ile',) or eqv()->find('dużo',))
        Interrogative := 1;
}

FLG => CardNumP
{
    # 'dwa tysiące lat' => 'two thousand years'
    find("N",)->Num := 1;
}

#!!! TRACE listowe.t


DROGI => DEAR
{
    warning('UNEXPECTED: DROGI');
}

sub DEAR::surface()
{
    warning('UNEXPECTED: DEAR::surface');
	$D := insert_left("A",);
	$D->Equiv := "dear";
	return gensurface();
}

#!!! TRACE okol.m

#

sub AdvP::dependent_speech()
{
    %SubC [cat() = SubC];
    set_dependent_speech();
    %SubC->dependent_speech();
}

sub AdvP::default()
{
    # 'co najmniej trzeci' => 'to say the least third'
    %PostAdv [ Post = 1 ];

    # 'po wrocławsku' => 'in a Wrocław manner'
    %Head [ label() = "#" ];

    order %Head < %PostAdv;
}

#!!! TRACE okol.t

#

#
#

#
#
#
#
#

#
FPSs=>CAdvP
{

}

PR=>Prep {}

:okol => :adv
{
}

:słowo_rok => :word_year
{
}

ROK => YEAR
{
}

FSPEC=>TEMP
{
    $H := find("GNP",);

    if($H)
    {
        $H.Prep := $H.SpecPrep;

        if($H.SpecDef = "0")
            $d := zero;
        else if($H.SpecDef = "D")
            $d := the;
        else if($H.SpecDef = "I")
            $d := a;

        if($d)
            $H.setDef($d, 99);

        delete("Prep",);
        $L := label();
        replace_with($H);
        $H->change_label($L);
    }
}

#
FPR=>TEMP
{
    '$sam' => 'alone' {warning('UNEXPECTED: FPR - sam');}
    '$się' => 'oneself' {warning('UNEXPECTED: FPR - się');}
    # 'Ustaw jako katalog zakładek' => 'Place the catalogue of bookmarks'
    'jako' => 'as' {}

    # 'pięć lat temu' => 'five years ago'
    'temu' => 'ago' {}

    # 'szczególnie w Holandii' => 'particularly in Netherlands'
    :partykuła => :particle {}

    # 'między modemem i drukarką' => 'between the modem and the printer'
    :a => :"and" { Prep := null();}

    # 'sam na sam z Markiem' => 'one-on-one with Marek'
    $H := find("GNP",) or $H := find("AP","#") or $H := find('oneself',"#");

    if($H)
    {
        if($Prep := find("Prep",) or $Prep := find("Conj",))
        {
            $H.Prep := $Prep.Equiv;
            if ($Prep->cat() = "Conj")
            {
                # 'jeśli chodzi o pociągi, to mam o nich złe zdanie' => 'as for trains, I have a bad opinion about them'
                $H.ConjType := $Prep.Prep1;
            }
            delete($Prep,);
        }
        else if(find('as',))
        {
            delete(find('as',),);
            $H.Prep := "as";
        }
        else if(find('ago',))
        {
            delete(find('ago',),);
            $H.Prep := "ago";
        }
        else
            warning("fraza przyimkowa bez przyimka?!?");

        # konstrukcja typu: "sam ze sobą"
        if ($ALONE := find('alone',) and find('oneself',))
        {
            warning('UNEXPECTED: FPR - $ALONE := find(alone,) and find(oneself,)');
            delete($ALONE,);
        }
        # 'szczególnie w Rosji' => 'particularly in Russia'
        if($PA := find(,particle))
            delete($PA,);

        # 'pomiędzy Adamem a programistą' => 'between Adam and the programmer'
        if($andC := find(,"and"))
            delete($andC,);

        $L := label();
        replace_with($H);
        $H->change_label($L);
        $H->insert_left($PA,);
        $PA->change_label(particle);

        $H->insert_right($andC,);
        $andC->change_label("and");
    }
    else
    {
        # 'Marek sam ze sobą' => 'Marek alone with oneself'
        warning("FPR bez głowy???");
    }
}

#

#
#
#
#

#

#
#
#
#
#
#

#

#
#

#
#


PS => Adv
{
    # 'po wrocławsku' => 'in a Wrocław manner'
    'po' => 'in a manner' {}

    if($po := find('in a manner',))
    {
        delete($po,);
        Equiv := "in a " + find(,"#")->Equiv + " manner";
    }

    if (@.Stopień = równy)
        Degree := positive;
    else if (@.Stopień = wyższy)
    {
        # 'bardziej matematycznie' => 'more mathematically'
        Degree := comparative;
    }
    else
    {
        # 'najbardziej matematycznie' => 'most mathematically'
        Degree := superlative;
    }

    if (@.Typ = interrog)
    {
        # 'gdzież poszedł?' => 'where on earth did he go?'
        Interrogative := 1;
    }

    S := @.S;
}

FPS => AdvP
{
    # 'wcale mi się nie podobasz' p=>e 'I don~t like you at all'
    if(find("Adv","#")->Equiv = "at all")
        FinalAtAll := 1;

    # 'będzie łatwo Markowi umrzeć' => 'it will be easy for Marek to die'
    :dop1=>:compl1 {}
    :dop2=>:compl2 {warning('UNEXPECTED: FPS - dop2');}

    # reguły dyżurnego transferu partykuł 'mniej', 'bardziej'

    'wystarczająco' => 'enough' {warning('UNEXPECTED: FPS - wystarczająco');}
    'na tyle' => 'enough' {warning('UNEXPECTED: FPS - na tyle');}
    # 'tak jak obiecywałem' => 'the way I promised'
    :zapowiednik => :announcer {}
    'tak' => 'so' {}
    '$taki' => 'so' {warning('UNEXPECTED: FPS - $taki');}
    # 'zacznie sama' => 'he will start alone'
    '$sam' => 'alone' { C:= @.P; Equiv := "alone";}
    'jak' => 'as' {}
    # 'tam dokąd idę' => 'where I am going'
    'tam' => 'there' {}
    # 'wtedy gdy malowałem ptaki' => 'when I painted birds'
    'wtedy' => 'then' {}
    'dokąd' => 'where' {}
    # 'tam gdzie w zeszłym roku spędziłem wakacje' => 'where last year I spent my holidays'
    'gdzie' => 'where' {}
    # 'tam skąd pochodzę' => 'from where I come'
    'skąd' => 'from where' {}
    'gdy' => 'when' {}
    # 'wtedy, kiedy Ci powiem' => 'when I will tell you'
    'kiedy' => 'when' {}
    '@jakby' => 'as if' {warning('UNEXPECTED: FPS - @jakby');}
    'temu' => 'ago' {warning('UNEXPECTED: FPR - temu');}
    # 'nie tak jak obiecywałem' => 'not so how I promised'
    'nie' => 'not' {}

    inherit("Disj",);
    inherit("Neg",);
    inherit("Def",);

    # usunięcie niepotrzebnych poddrzew powstałych
    # z zaimków 'tam' i 'wtedy' i 'jak'

    # 'pójdę tam gdzie chcę' => 'I will go where I want'
    if(delete('there',))
        delete(',',);

    # 'wtedy gdy malowałem ptaki' => 'when I painted birds'
    if(delete('then',))
        delete(',',);

    # 'śpiewał tak, jak Marek śpiewał' => 'he sang the way Marek sang'
    if($z := find('so',announcer))
    {
        $z->change_category('the way');
        delete('as',);
        delete(',',);
    }

    S := @.S;

    if ($mam := find("Adv",) and $mam->find('more and more',))
    {
        warning('UNEXPECTED: FPS - $mam := find("Adv",) and $mam->find(more and more,)');
        $mam.Equiv := "more and more";
        if ($A := find("Adv", "#"))
        {
            delete($mam,);
            insert_left('and',);
            $Ad := insert_left("Adv",);
            if ($A->Inflection = "A0" or $A->Inflection = "AV0")
            {
                if (find('less',))
                    $Ad.Equiv := "less";
                else
                    $Ad.Equiv := "more";
            }
            else
            {
                  $Ad.Equiv := $A->Equiv;
                 $Ad.Inflection := $A->Inflection;
                 $Ad.Degree := $A->Degree;
            }
        }
    }
    ##### Jeśli przypadkiem leksemu "@Sam" jest celownik (np. "Samemu"), to tłumaczymy na oneself

    # 'nie dasz samemu rady' => 'you will can~t cope yourself'
    if ($alone := find('alone',) and $alone.C = cel)
    {
        delete('alone',);
        insert_right("ReflPron",);
    }

    #####Ustalenie podmiotu domyślnego po spójniku @jakby - jest to powtórzenie - jak
    ##### po innych spójnikach 'fleksyjnych'
    if(find('as if',))
    {
        warning('UNEXPECTED: FPS - find(as if,)');
        $VP := find("VP", "#");
        if(not ($VP->find("NP", subject)))
        {
            $PersPron := insert_left("PersPron", subject);
            $PersPron.Num := Conj.Num;
            $PersPron.Person := Conj.Person;
            #Jeśli tylko jest to zgodne z semantyką czasownika, to podmiot jest osobowy
            if ($VP.S ^ hum)
            {
                $PersPron.S := hum;
            }
            else
            {
                $PersPron.S := $VP.S;
            }
            #Trzeba ustalić jeszcze rodzaj (Gender) podmiotu - na podstawie przyjętej semantyki i rodzaju czasownika w zdaniu polskim
            if(@.R = ż and S < hum)
            {
                Gender := fem;
            }
            else if((@.R = mo or @.R = "mż") and S < hum)
            {
                Gender := masc;
            }
            else
                Gender := neut;
        }
    }

    ####TRANSFER DOPEŁNIEŃ (Taki jak dla czasowników)

    # MW opis w *.g mówi, że dopełnienia nie zostały uwzględnione

    # 'coraz bardziej inteligentny' => 'more and more intelligent'
    %Head [ label() = "#" ];

    if(%Head)
    {
        # 'będzie łatwo Markowi umrzeć' => 'it will be easy for Marek to die'
        if(undefined(Compl1) and %Head->Compl1)
        {
            Compl1 := %Head->Compl1;
            Prep1  := %Head->Prep1;
            Def1   := %Head->Def1;
        }

        if(undefined(Compl2) and %Head->Compl2)
        {
            Compl2 := %Head->Compl2;
            Prep2  := %Head->Prep2;
            Def2   := %Head->Def2;
        }
    }

    if($COMPL := find(,compl1))
    {
        # 'będzie łatwo Markowi umrzeć' => 'it will be easy for Marek to die'
        if($COMPL.cat() = "GNP")
        {
            $COMPL.Prep := Prep1;

            if ($COMPL->find("SubC", "#"))
            {
                warning('UNEXPECTED: $COMPL->find("SubC", "#")');
                if ($COMPL.Prep != '' and SubC.Type != ob)
                {
                    warning('UNEXPECTED: $COMPL.Prep !=  and SubC.Type != ob');
                    SubC.Type := gerund;
                }
#
            }

        }
        if($COMPL.cat() = "AdvP")
        {
            warning('UNEXPECTED: $COMPL.cat() = "AdvP" 1');
            if(Compl1 = "AJ")
            {
                warning('UNEXPECTED: Compl1 = "AJ"');
                $COMPL.Adj := true;
            }
        }
        if($COMPL.cat() = "SubC")
        {
            warning('UNEXPECTED: $COMPL.cat() = "SubC"');
            $COMPL.delete("Prep",);

            $COMPL.Type := Compl1;
            $COMPL.Prep := Prep1;
        }
    }

    if($COMPL := find(,compl2))
    {
        # 'nie było aż tak trudno oszukać ich' => 'it wasn~t so hard to cheat them'
        if($COMPL.cat() = "GNP")
        {
            warning('UNEXPECTED: 2 - $COMPL.cat() = "GNP"');
            $COMPL.Prep := Prep2;

            if ($COMPL->find("SubC", "#"))
            {
                warning('UNEXPECTED: 2 - $COMPL->find("SubC", "#")');
                if ($COMPL.Prep != '' and SubC.Type != ob)
                {
                    warning('UNEXPECTED: 2 - $COMPL.Prep !=  and SubC.Type != ob');
                    SubC.Type := gerund;
                }
#
            }

        }
        if($COMPL.cat() = "AdvP")
        {
            warning('UNEXPECTED: 2 - $COMPL.cat() = "AdvP"');
            if(Compl2 = "AJ")
            {
                warning('UNEXPECTED: 2 - Compl2 = "AJ"');
                $COMPL.Adj := true;
            }
        }
        if($COMPL.cat() = "SubC")
        {
            warning('UNEXPECTED: 2 - $COMPL.cat() = "SubC"');
            $COMPL.delete("Prep",);

            $COMPL.Type := Compl2;
            $COMPL.Prep := Prep2;
        }
    }

    adj_adv_degree("Adv");

    # @todo
    # "zrobiłem to tak dobrze" [?]
    if ($TH := find("SubC",) and $TH->Type = that)
    {
        # 'zrobili to tak dobrze, że dostali zapłatę' => 'they did it so well that they got the payment'
        $TH.Prep := that;
    }
    else if($SUBC := find("SubC",))
    {
        delete('so',);
        insert_left('enough',);
        if ($SUBC.Type = 'in_order_to')
        {
            warning('UNEXPECTED: FPS - in_order_to');
            $SUBC.Type := 'to';
        }
        else
        {
            # 'tak szybko, żeby zdążyć' => 'quickly enough to be on time'
            $SUBC.Type := 'to';
            $SUBC.Prep := 'for';
        }
    }

    # We frazie "najlepiej, jak umiałem" typ zdania względnego w zd. angielskim oznacza, że zaczyna się ono na 'that'
    # i nie należy umieszczać je w przecinkach
    if($RELC := find("RelC",))
    {
        warning('UNEXPECTED: $RELC := find("RelC",)');
        $RelC.Type := no_commas;
    }

    #Transfer fraz typu 'na tyle dobrze', by (że)
    if ($SUBC := find("SubC",) and find(enough,))
    {
        warning('UNEXPECTED: $SUBC := find("SubC",) and find(enough,)');
        if ($SUBC.Type = 'in_order_to')
        {
            warning('UNEXPECTED: $SUBC.Type = in_order_to');
            $SUBC.Type := 'to';
        }
        else
        {
            warning('UNEXPECTED: else - $SUBC.Type = in_order_to');
            $SUBC.Type := 'to';
            $SUBC.Prep := 'for';
        }
    }

    #Tak szybko jak...; szybko jak...
    if (find('as',))
    {
        # 'Podobnie jak w przypadku innych leków' => 'As similarly as in case of other medicines'
        if ($SO := find('so',))
            $SO->change_category('as');
        else
            insert_left('as',);
    }

    #Tak szybko by...
    if (find('so',) and $TO := find("SubC",) and $TO.Type = 'in order to')
    {
        warning('UNEXPECTED: find(so,) and $TO := find("SubC",) and $TO.Type');
        $TO.Prep := as;
        $TO.Type := 'to';
    }
}


SFPS => AdvPS
{
    # 'biegnie przez łąki i przez knieje' => 'he is running through meadows and through wild forests'
    if ($Prep1 := find("CAdvP",)->find("Conj",)->Prep1)
    {
        # 'U ludzi wardenafil ani w monoterapii, ani w skojarzeniu z kwasem acetylosalicylowym nie wpływa na czas krwawienia' => 'At people wardenafil neither in the monotherapy, nor in associating with the acetylsalicylic acid doesn~t influence the bleeding time'
        foreach $S
        {
            if ($Conj:= $S->find("Conj",) and ($Conj->eqv()->Ps1 = 8 or $Conj->eqv()->Ps1 = 9))
            {
                if ($Prep1 = "0")
                      $Conj->Equiv := "";
                else
                      $Conj->Equiv := $Prep1;
            }
        }
    }
}

#
#
ZPS => AdvPron {}

#
#

:dzień => :day {}
:miesiąc => :month {}
'br.':rok => 'this year':rok {}
:rok => :year {}

#!!! TRACE przymiotnik.i

#

sub ::extract_eng_form(einfl,name,def)
{
    warning('UNDEFINED: extract_eng_form');
    $regexp := $name + "\[" + "([A-Za-z]+)" + "\]";

    if($einfl =~ $regexp)
        return $1;

    return $def;
}

sub AdjPron::surface()
{
    if(Inflection = sl)
    {
        warning('UNEXPECTED: AdjPron - Inflection = sl');
        return nounderscores(Equiv);
    }

    if(RelPron)
    {
        if(Type = unknown)
        {
#
            # 'której nie ma' => 'which is missing'
                # @todo pod windowsem wychodziło whom, czemu?
                return "which";

            if(S ^ "-hum")
            {
                # 'który wierzy' => 'which believes'
                return "which";
            }
            else if(Case = acc)
            {
                warning('UNEXPECTED: AdjPron - whom');
                return "whom";
            }
            else
            {
                warning('UNEXPECTED: AdjPron - who');
                return "who";
            }
        }
        else if(Type = defining)
        {
            warning('UNEXPECTED: AdjPron - that');
            # 'tamten koszyk' => 'that basket'
            return "that";
        }
        else if(Type = non_defining)
        {
            warning('UNEXPECTED: Type = non_defining');
            return "which";

            if(S ^ "-hum")
            {
                warning('UNEXPECTED: AdjPron - which');
                return "which";
            }
            else if(Case = acc)
            {
                warning('UNEXPECTED: AdjPron - whom');
                return "whom";
            }
            else
            {
                warning('UNEXPECTED: AdjPron - who');
                return "who";
            }
        }
    }

    if(Num = 2)
    {
        if(Equiv = "this")
        {
            # 'te krzesła' => 'these chairs'
            return "these";
        }

        if(Equiv = "that")
        {
            # 'tamtych dziewczyn' => 'of those girls'
            return "those";
        }
    }

    return nounderscores(Equiv);
}

sub AP::surface()
{
    if(Prep and Prep != none)
    {
#
        # 'na zielonym krześle' => 'on the green chair'
        warning('UNDEFINED: AP: surface');
        $PREP := insert_left("Prep",);
        $PREP->Equiv := strip_quotes(Prep);
    }

    return gensurface();
}

sub A::inflection(w,i)
{
    # instrukcja fleksyjna składa się z pięciu członów
    if($i =~ /^(.*_|(?:))([A-Za-z]+[0-9]*)-?([A-Za-z]*)(:[0-9u]+|(?:))(!?)$/)
    {
        $ia := $1; $ib := $2; $ic := $3; $id := $4; $ie := $5;

        if($ia != "")
            $name := $ia + $ib;
        else
            $name := $w + "_" + $ib;

        $mcode := "A";

        if(($id != "" and $id =~ /^:.*u$/) or Upper)
            return pair($name,"u" + get_enmorpho($mcode, 0, 0, Degree));
        else
        {
            # 'większy dom' => 'bigger house'
            return pair($name,get_enmorpho($mcode, 0, 0, Degree));
        }
    }

    warning("błędna instrukcja fleksyjna:");
    warning($i);

    return $w;
}

sub A::surface()
{
    if(Inflection and Inflection != "")
    {
        return inflection_cycle(Equiv, Inflection);
    }
    else
    {
        if(Degree != comparative and Degree != superlative or
           Comp or
           Superl)
        {
            if(Upper)
            {
                # 'lubię Wojskowe Instytuty Geograficzne' => 'I like Military Geographical Institutes'
                return ucfirst(Equiv);
            }
            else
            {
                # 'wysoki płot' => 'high fence'
                return Equiv;
            }
        }

        if(Equiv =~ /^(.* )([^ ]+)$/)
        {
            return $1 & inflection($2,"A");
        }
        else
        {
            # 'większy dom' => 'bigger house'
            return inflection(Equiv,"A");
        }
    }
}

sub Adv::inflection(w,i)
{
    # instrukcja fleksyjna składa się z pięciu członów
    if($i =~ /^(.*_|(?:))([A-Za-z]+[0-9]*)-?([A-Za-z]*)(:[0-9u]+|(?:))(!?)$/)
    {
        $ia := $1; $ib := $2; $ic := $3; $id := $4; $ie := $5;

        if($ia != "")
            $name := $ia + $ib;
        else
            $name := $w + "_" + $ib;

#
#
#
#
        $mcode := "Adv";

        if($id != "" and $id =~ /^:([0-9])/)
            $num := atoi($1);
        else
            $num := Num;

        $num := Num;

        if(($id != "" and $id =~ /^:.*u$/) or Upper)
                return pair($name,"u" + get_enmorpho($mcode, 0, 0, Degree));
        else
                return pair($name,get_enmorpho($mcode, 0, 0, Degree));
    }

    warning("błędna instrukcja fleksyjna:");
    warning($i);

    return $w;
}

sub Adv::surface()
{
    if(Inflection and Inflection != "")
    {
        # 'praca w nadgodzinach mi nie przeszkadza' => 'the work overtime isn~t disturbing me'
        return inflection_cycle(Equiv, Inflection);
    }
    else
    {
        if((Degree != comparative and Degree != superlative)
           or Comp
           or Superl)
        {
            # 'co najmniej pięć' => 'at least five'
            # 'brązowo' => 'brown'
            return Equiv;
        }

        if(Equiv =~ /^(.* )([^ ]+)$/)
        {
            # MW wielowyrazowe przysłówki
            warning('UNEXPECTED: Equiv =~ /^(.* )([^ ]+)$/');
            return $1 & inflection($2,"adv");
        }
        else
        {
            # 'bardziej kolorowo' => 'more colourfully'
            return inflection(Equiv,"adv");
        }
    }
}

#!!! TRACE przymiotnik.m

#

#
sub AdjPron::default()
{
    # 'każdy z nas lubi kino' => 'each of us likes the cinema'
    if(Equiv = "each")
    {
        # @cat{SP,fraza typu 'spośród'}
        if(label() = "#" and parent()->cat() = "GNP" and not parent()->find("SP",))
        {
            # 'każdy lubi kino' => 'everyone likes the cinema'
            Equiv := "everyone";
        }
    }
    else if(Equiv = "so")
    {
        if(parent() and parent()->cat() = "GNP")
        {
            # 'taka nudna książka' => 'such a boring book'
            Equiv := "such";
        }
    }
    else if(Equiv = "one" and Num = 2)
    {
        # 'jedne z moich spodni' => 'ones of my trousers'
        Equiv := "ones";
    }
}

sub AP::default()
{
    # 'kamień prawie tej samej wielkości' => 'stone of almost the same size'
    # 'czarna chmura' => 'black cloud'

    %PostAdv [ Post = 1 ];
    %Head [ label() = "#" ];

    order %Head < %PostAdv;
}



#
sub A::post()
{
    # 'wiersz dada' => 'Dada poem'
    return Post;
}

sub APS::post()
{
    foreach $s
    {
        # 'czarny, okrągły stolik' => 'black, round table'
        if(($s->cat() = "AP" or $s->cat() = "CAP") and $s->post())
        {
            # 'kamień prawie tej samej wielkości, tego samego koloru' => 'stone of almost the same size, of the same colour'
            return 1;
        }
    }
    return 0;
}

sub CAP::post()
{
    # 'czarne i wygodne krzesło' => 'black and comfortable chair'
    return find(,"#")->post();
}

sub AP::post()
{
    # dla fraz przymiotnikowych ze slotem - ominięcie buga
    # związanego z nieprzenoszeniem atrybutu Post

    if(($oth := (find("A","#")->find("OTH","#")))
        and $oth->find("TFRAG",)
        and $oth->find(,slot1))
    {
        # 'fotel pod kolor tego stolika' p=>e 'armchair to match this table'
        return 1;
    }

    if($aps := find("APS","#"))
    {
        # 'żółte i czerwone tulipany' => 'yellow and red tulips'
        return $aps->post();
    }

    %HeadVP [cat() = "VP" && label() = "#"];
    %SubC [cat() = "SubC"];
    %RelC [cat() = "RelC"];
    %Compl1 [label() = compl1];
    %Compl2 [label() = compl2];

    if (%HeadVP->more_than_verb()
        or %SubC or %RelC or %Compl1 or %Compl2
        or find("SP",)
        or find("ThanP",)
        or Post)
    {
        # 'kamień prawie tej samej wielkości' => 'stone of almost the same size'
        return 1;
    }
    else
    {
        return 0;
    }
}

sub ::more_than_verb()
{
    # @cat{AdvP,fraza przysłówkowa}
    # @cat{Hk,element jednostki wielowyrazowej}
    foreach $S
        if($S->cat() != "V" and not ($S->cat() = "Hk" or $S->cat() = "AdvP" and $S->label() = "adv" and $S->count_words() < 2))
        {
            # 'biały śnieg' => 'white snow'
            return 1;
        }

    return 0;
}

sub APS::default()
{
    # 'białe i czerwone tulipany' => 'white and red tulips'
    # 'zarówno piękne, jak i inteligentne' p=>e 'both beautiful and intelligent'
    if(find("CAP",)->Nocomma)
        delete(',',);
}

#!!! TRACE przymiotnik.t

#

#

#
#

#

#
#
#
#

#
#

#

#
#
#
#
#
#

#
#

#
#


ZP=>AdjPron
{
    Num := @.L;
    if (@.Typ = pytajny)
       Interrogative :=1;

    if(@.Typ = "który")
    {
        RelPron := 1;
        Type := unknown;
        S := @.S;

        if(@.P = mian)
        {
            # 'który' => 'which'
            # 'która' => 'which'
            # 'którzy' => 'which'
            Case := nom;
        }
        else
        {
            # 'której' => 'of which'
            Case := acc;
        }
        Interrogative := 1;

        Def := zero;
        DefLevel := 100;
    }
}

ZD =>AdjPron
{
    Num := 1;
}

#
#
P => A
{
    if(@.Sh = 2)
        Upper := 1;

    # 'książka tego rodzaju' => 'that kind of book'
    # 'elektroenergetyczny przedmiot' => 'electrical power engineering object'
    if(not Pre and Equiv =~ /[^ ] [^ ]+ [^ ]/)
    {
        # 'kamień prawie tej samej wielkości' => 'stone of almost the same size'
        Post := 1;
    }

    if (@.Stopień = równy)
    {
        # 'ładny' => 'pretty'
        # 'punktualny' => 'punctual'
        Degree := positive;
    }
    else if (@.Stopień = wyższy)
    {
        # 'ładniejszy' => 'prettier'
        # 'bardziej punktualny' => 'more punctual'
        Degree := comparative;
    }
    else
    {
        # 'najładniejszy' => 'prettiest'
        # 'najbardziej punktualny' => 'most punctual'
        Degree := superlative;
	Def := 1;
#
#
#
#
#
#
#
#
    }
}

#
PN => A {}


sub ::adj_adv_degree(cat)
{
    $mam := 0;      # czy jest 'more and more' lub równoważne

    foreach $s
    {
        $childS := $s->find("Adv", );

        if($s->cat() = "AdvP" and $s->label() != "#")
        {
            if($childS->More)
            {
                # 'bardziej inteligentny' => 'more intelligent'
                # 'bardziej inteligentny ode mnie' => 'more intelligent than me'

                # 'bardziej matematycznie' => 'more mathematically'
                # 'bardziej daleko' => 'farther'
                delete($s,);
                Degree := comparative;

                if(not $mam)
                {
                    $Head := find($cat,"#");
                    $Head.Degree := comparative;
                }
            }
            else if($childS->Most)
            {
                # 'najbardziej szybki' => 'fastest'
                # 'najbardziej inteligentny' => 'most intelligent'
                # 'jestem najbardziej inteligentnym człowiekiem' => 'I am the most intelligent man'

                # 'najbardziej matematycznie' => 'most mathematically'
                delete($s,);
                Degree := superlative;
                $Head := find($cat,"#");
                $Head.Degree := superlative;
            }
            if($childS->Less)
            {
                # 'mniej matematyczny' => 'less mathematical'
                # 'coraz to mniej matematyczny' => 'less and less mathematical'

                # 'mniej matematycznie' => 'less mathematically'
                # 'coraz to mniej matematycznie' => 'less and less mathematically'
                if($mam)
                {
                    delete($s,);
                    $mam->Equiv := "less and less";
                }
            }
            if($childS->Mam)
            {
                # 'coraz szybszy' => 'faster and faster'

                # 'coraz to bardziej daleko' => 'more and more far'
                Degree := comparative;
                $Head := find($cat,"#");
                $Head.Degree := positive;
                $mam := $s;
            }

            # powinno samo wyjść:
            # 'najmniej matematyczny' => 'least mathematical'
        }
    }
}

FP => AP
{
    # 'na tyle inteligentny, by odejść' => 'intelligent enough to walk away'

    # 'niezależny od Ciebie' => 'independent of you'
    :dop1=>:compl1 {}
    # 'wdzięczny siostrze za pomoc' => 'grateful to the sister for the help'
    :dop2=>:compl2 {}

    # reguły dyżurnego transferu parykuł 'mniej', 'bardziej' itp.
    # 'wystarczająco szybki żeby grać' => 'fast enough in order to play'
    'wystarczająco' => 'enough' { Post := 1;}
    # 'Karol jest tak inteligentny' => 'Karol is so intelligent'
    'tak' => 'so' {}

    # 'Karol jest taki inteligentny' => 'Karol is so intelligent'
    '$taki' => 'so'{ Equiv := "so";}

    # 'tak inteligentny jak Karol' => 'as intelligent as Karol'
    'jak' => 'as' {}
    # 'nie szybszy ode mnie' => 'not faster than me'
    'nie' => 'not' {}

    inherit("Def",);
    inherit("Post",);

    %Head [ label() = "#" ];

    if(%Head)
    {
if(undefined(Compl1) and %Head->Compl1)
        {
            # 'niezależny od Ciebie' => 'independent of you'
            # 'wdzięczny komuś za coś' => 'grateful to somebody for something'
            Compl1 := %Head->Compl1;
            Prep1  := %Head->Prep1;
            Def1   := %Head->Def1;
        }
if(undefined(Compl2) and %Head->Compl2)
        {
            # 'niezależny od Ciebie' => 'independent of you'
            # 'wdzięczny komuś za coś' => 'grateful to somebody for something'
            Compl2 := %Head->Compl2;
            Prep2  := %Head->Prep2;
            Def2   := %Head->Def2;
        }
    }


    # transfer dopełnień
if($COMPL := find(,compl1))
    {
        if($COMPL.cat() = "GNP")
        {
            # 'niezależny od Ciebie' => 'independent of you'
            # 'wdzięczny komuś za coś' => 'grateful to somebody for something'
            $COMPL.Prep := Prep1;

            if ($SUBC := $COMPL->find ("SubC", "#"))
            {
                warning('UNEXPECTED: SubC 1');
                if ($COMPL.Prep != '' and SubC.Type != ob)
                {
                    SubC.Type := gerund;
                }

                if(1 = 1)
                    $SUBC->replace_with($COMPL);
                else
                     delete($COMPL,);
           }
        }

        if($COMPL.cat() = "AdvP")
        {
            warning('UNEXPECTED: AdvP');
            if(Compl1 = "AJ")
            {
                $COMPL.Adj := true;
            }
        }

        if($COMPL.cat() = "SubC" or $COMPL.cat() = "VP")
        {
            # 'pewny, że pojedzie do Poznania' => 'sure that he will go to Poznań'
            $COMPL.delete("Prep",);

            $COMPL.Type := Compl1;
            $COMPL.Prep := Prep1;
        }
    }
if($COMPL := find(,compl2))
    {
        if($COMPL.cat() = "GNP")
        {
            # 'niezależny od Ciebie' => 'independent of you'
            # 'wdzięczny komuś za coś' => 'grateful to somebody for something'
            $COMPL.Prep := Prep2;

            if ($SUBC := $COMPL->find ("SubC", "#"))
            {
                warning('UNEXPECTED: SubC 1');
                if ($COMPL.Prep != '' and SubC.Type != ob)
                {
                    SubC.Type := gerund;
                }

                if(2 = 1)
                    $SUBC->replace_with($COMPL);
                else
                     delete($COMPL,);
           }
        }

        if($COMPL.cat() = "AdvP")
        {
            warning('UNEXPECTED: AdvP');
            if(Compl2 = "AJ")
            {
                $COMPL.Adj := true;
            }
        }

        if($COMPL.cat() = "SubC" or $COMPL.cat() = "VP")
        {
            # 'pewny, że pojedzie do Poznania' => 'sure that he will go to Poznań'
            $COMPL.delete("Prep",);

            $COMPL.Type := Compl2;
            $COMPL.Prep := Prep2;
        }
    }

    # 'szybszy' => 'faster'
    # 'najszybszy' => 'fastest'
    adj_adv_degree("A");

    if ($mam := find("Adv",) and $mam->find('more and more',))
    {
        $mam.Equiv := "more and more";
        if ($A := find("A", "#"))
        {
            # 'kraj coraz bardziej niezależny' => 'more and more independent country'
            delete($mam,);
            insert_left('and',);
            $Aj := insert_left("A",);
            if ($A->Inflection = "A0")
            {
                if (find('less',)) {$Aj.Equiv := "less";} else {$Aj.Equiv := "more";}
            }
            else
            {
                $Aj.Equiv := $A->Equiv;
                $Aj.Inflection := $A->Inflection;
                $Aj.Degree := $A->Degree;
            }
        }
    }
    # We frazie "najgłupszy, jakiego widziałem" typ zdania względnego w zd. angielskim oznacza, że zaczyna się ono na 'that'
    # i nie należy umieszczać je w przecinkach

    if($RELC := find("RelC",))
        $RelC.Type := no_commas;

    #Transfer fraz typu 'na tyle mądry', by (że)
    if ($SUBC := find("SubC",) and find(enough,))
    {
        warning('UNEXPECTED: SubC');
        if ($SUBC.Type = 'in_order_to')
        {
            $SUBC.Type := 'to';
        }
        else
        {
            $SUBC.Type := 'to';
            $SUBC.Prep := 'for';
        }
    }

    #Tak mądry jak...; mądry jak...
    if (find('as',) or find("SubC",)->Type = how)
    {
        Post := 1;
        if ($SO := find("AdvP",)->find("Adv","#") and $SO->Equiv = so)
        {
            # 'tak mądry jak ja' => 'as clever as I'
            $SO->Equiv := as;
        }
        else
        {
            # 'inteligentny jak ona' => 'as intelligent as she'
            insert_left('as',);
        }
        find("SubC",)->Prep := as;
    }

    #Tak mądry by...
    if ($SO := (find('so',) and $TO := find("SubC",) and $TO.Type = in_order_to))
    {
	# @todo na pewno tak powinno być tłumaczone?
        # 'tak mądry by kupić tego kota' => 'so clever as to buy this cat'
        $TO.Prep := as;
        $TO.Type := 'to';
        $SO->change_category('as');
    }

    # 'tak szybki, że doszedł pierwszy' => 'so fast that he reached first'
    if ($TH := find("SubC",) and $TH->Type = that)
        $TH.Prep := that;

    # Na tyle mądry
    if (find('for',) and find('tyle',))
    {
        # 'na tyle inteligentny' => 'intelligent enough'
        delete('for',);
        delete('tyle',);
        $adv := insert_left("Adv",);
        $adv.Post := 1;
        $adv.Equiv := "enough";
    }
#
    # 'najszybszy człowiek' => 'the fastest man'
#
#
#
#
#
#
    if(Degree = superlative)
        Def := the;
}

SFP=>APS
{
    if ($Prep1 := find("CAP",)->find("Conj",)->Prep1)
        foreach $S
        {
            if ($Conj:= $S->find("Conj",) and ($Conj->eqv()->Ps1 = 8 or $Conj->eqv()->Ps1 = 9))
            {
                if ($Prep1 = "0")
                {
                    warning('UNEXPECTED: SFP - Prep1=0');
                    $Conj->Equiv := "";
                }
                else
                {
                    # 'zarówno czerwony, jak i niebieski'
                    $Conj->Equiv := $Prep1;
                }
            }
        }
}

FPs=>CAP
{
    # 'zarówno piękne, jak i inteligentne' p=>e 'both beautiful and intelligent'
    if(find("Conj",)->Nocomma)
        Nocomma := 1;
}

FNIŻ=>ThanP
{
    # trzeba odróżnić "od..." od "niż...", w pierwszym przypadku
    # musimy wyrzucić wszelkie przyimki z GNP
    $NoPrep := find("Conj",)->NoPrep;
    delete("Conj",);
    insert_left("Prep",)->Equiv := "than";

    # 'szybszy niż strzała' => 'faster than the arrow'
    if($n := find("GNP",) and $NoPrep)
    {
        # 'szybszy od strzały' => 'faster than the arrow'
        $n.Prep := none;
        $n.change_case(acc);
    }
}

#!!! TRACE rzeczownik.i

#

#
#
#
#
#
sub ::get_enmorpho(m,n,p,c)
{
    if($m = "N")
    {
        if($c = sax)
        {
            if($n = 2)
            {
                # 'rowery Adamów' => 'Adams~ bicycles'
                return "saxonpl";
            }
            else
            {
                # 'rower Adama' => 'Adam~s bicycle'
                return "saxon";
            }
        }

        if($n = 2)
        {
            # 'opisać tkanki łączne' => 'to describe connective tissues'
            return "plural";
        }
        else
        {
            # 'opisać tkankę łączną' => 'to describe the connective tissue'
            return "sing";
        }
    }

    if($c = "det")
    {
        warning('UNEXPECTED: get_enmorpho - $c = "det"');
        if($n = 2)
        {
            warning('UNEXPECTED: get_enmorpho - $n = 2');
            return "detpl";
        }
        else
        {
            warning('UNEXPECTED: get_enmorpho - else $n = 2');
            return "detsg";
        }
    }

    if($m = "Vpres")
    {
        # 'wszyscy ją lubią' => 'everyone like her'
        if($n = 1 and $p = 3)
            return "pres3s";
        else
            return "pres";
    }

    if($m = "Vpt")
    {
        # 'przyglądałam się domowi' => 'I watched the house'
        return "pt";
    }

    if($m = "Vpp")
    {
        # 'być więzionym' => 'to be held prisoner'
        return "pp";
    }

    if($m = "Vgr")
    {
        # 'przyglądam się domowi' => 'I am watching the house'
        return "gr";
    }

    if($m = "A" or $m = "Adv")
    {
        if($c = "comparative")
        {
            # 'większy dom' => 'bigger house'
            return "com";
        }
        if($c = "superlative")
        {
            # 'największy dom' => 'the biggest house'
            return "sup";
        }
    }
}

sub N::inflection(w,i)
{
    # instrukcja fleksyjna składa się z pięciu członów
    if($i =~ /^(.*_|(?:))([A-Za-z]+[0-9]*)-?([A-Za-z]*)(:[0-9u]+|(?:))(!?)$/)
    {
        $ia := $1; $ib := $2; $ic := $3; $id := $4; $ie := $5;

        if($ia != "")
            $name := $ia + $ib;
        else
            $name := $w + "_" + $ib;

        if($ic != "")
            warning("unexpected sublexeme info");
        else
            $mcode := $ib;

        $num := Num;

        if(($id != "" and $id =~ /^:.*u$/) or Upper)
                return pair($name,"u" + get_enmorpho($mcode, $num, 0, Case));
        else
                return pair($name,get_enmorpho($mcode, $num, 0, Case));
    }

    warning("błędna instrukcja fleksyjna:");

    return $w;
}


sub ::inflection_cycle(e, t)
{
    # 'akredytywy' => 'letters of credit'
    # 'tkanka łączna' => 'connective tissue'

    # usuwamy zbędne spacje z początku
    if($e =~ /^ +(.*)$/)
        $e := $1;

    if($t =~ /^ +(.*)$/)
        $t := $1;

    # kolejno odrywamy wyrazy...
    if($e =~ /^([^, ]+)(.*)$/ or
       $e =~ /^(,)(.*)$/)
    {
        $ef := $1; $er := $2;

        # ... i odpowiadające im instrukcje fleksyjne
        if($t =~ /^([^ ]+)(.*)$/)
        {
            $tf := $1; $tr := $2;

            if($tf = "0")
                $rf := $ef;
            else
                $rf := inflection($ef,$tf);
        }
        else
        {
            # MW 'bla IV kwartał 2009 r.' => 'bla 4th quarter of 2009 yr'
            warning($e + " dla: " + $t);

            $rf := $ef;
        }

        if($er != "" and $er =~ /[^ ]/)
            return $rf & inflection_cycle($er,$tr);
        else
        {
            if($tr =~ /[^ ]/)
            {
                # 'oznakowuje się' => 'they are mark'
                warning("za dużo instrukcji fleksyjnych:");
                warning($e + " dla: " + $t);
            }
            return $rf;
        }
    }

    return $e;
}

sub ::determine_a_an(det)
{
    # 'jestem idiotą' => 'I am an idiot'
    # 'pół godziny' => 'half an hour'
    # 'jestem uniwersalnym żołnierzem' => 'I am a universal soldier'
    # 'jestem absolutnym pacanem' => 'I am an absolute plonker'
    if(Equiv)
    {
        # zabezpieczamy się przed dziwnymi sytuacjami kiedy już jest przedimek
        # w odpowiedniku
        if(Equiv =~ /^(a|an|the) /)
        {
            # 'jestem najbardziej inteligentnym człowiekiem' => 'I am the most intelligent man'
            $det->Equiv := "";
        }
        else if((Equiv =~ /^[aeiouAEIOU]/ and not Consonant) or
           Vowel)
        {
            $det->Equiv := "an";
        }
    }
    else
    {
        # 'podaj piszący długopis' => 'hand a writing pen'
        find(,)->determine_a_an($det);
    }
}

sub N::surface()
{
    # fraza ze slotami, odmiana musi nastąpić niżej
    # 'sprawy przewidziane w niniejszym dokumencie' p=>e 'matters regulated in this document'
    if (find("OTH","#") and undefined(Equiv))
        return gensurface();

    # 'dwa tysiące' p=>e 'two thousand'
    if(Num = 2 and Thousandlike and parent()->find("CardNum",))
        Num := 1;

    # 'ta lornetka' => 'these binoculars'
    if((Pl or Sg) and Case != sax and not Upper)
        return Equiv;

    if(Inflection and Inflection != "")
        return inflection_cycle(Equiv, Inflection);
    else
    {
        if(Num = 1 and Case != sax and not Upper)
        {
            # 'czarny kot' => 'black cat'
            return Equiv;
        }
        $mprefix := "";
        if(Upper)
        {
            # 'ta Lornetka' => 'these Binoculars'
            # @todo inna funkcja zamiast ucfirst dla wieloczłonowych?
            if((Pl or Sg) and Case != sax)
                return ucfirst(Equiv);
            else
                $mprefix := "u";
        }

        # 'czytelnie odwiedzający' => 'frequenting reading rooms'
        if(Equiv =~ /^(.* )([^ ]+)$/)
        {
            return $1 & pair($2 + "_N",get_enmorpho("N",Num,0,Case));
        }
        else
        {
            # 'tysiące' p=>e 'thousands'
            return pair(Equiv + "_N",$mprefix + get_enmorpho("N",Num,0,Case));
        }
    }
}

sub GNP::surface()
{
    # 'kobieta niepewna siebie' => 'woman unsure of herself'
    fix_reflexive_pronouns();

    if(%CardNum and %Head->cat() = "PersPron")
    {
    	# 'pięciu z nich zna Adama' => 'five of them know Adam'

        $PREP := %Head->insert_before("Prep",);
        $PREP->Equiv := "of";
        %Head->Case := acc;
    }

    # 'jesteśmy maszynami' => 'we are machines'
    if(not undefined(Def) and Def != zero and not %PossSaxon and %Head->cat() = "N" and
       (parent() or 50 < DefLevel))
    {
        # 'jestem robotem' => 'I am a robot'
        if (not (Num = 2 and Def = a))
        {
            $D := insert_left("Det",);
            $D->Equiv := Def;
        }
    }

    %Det [ cat() = "Det" ];
    %Such [ cat() = "AdjPron" and Equiv = such];
    %And [ cat() = 'and' ];
    order %And < %PreArticle < %Such < %Det;

    $det := null();
    # 'szukam mieszkania' => 'I am searching for the flat'
    foreach $s
    {
        if($det)
        {
            if($det->Equiv = "a")
                $s->determine_a_an($det);
            $det := null();
        }

        if($s->cat() = "Det")
            $det := $s;
    }

    if(Prep = "ago")
    {
        # 'pięć minut temu' => 'five minutes ago'
        $PREP := insert_right("Prep",);
        $PREP->Equiv := strip_quotes(Prep);
    }
    else if(Prep = saxon)
    {
        # 'pokój Marty' => 'Marta~s room'
        Def := zero;
        DefLevel := 100;
    }
    else if(Prep and (Prep != none))
    {
        # 'za kilka minut' => 'in a few minutes'
        $PREP := insert_left("Prep",);
        $PREP->Equiv := strip_quotes(Prep);

        %Particle [ label() = particle ];
        %Prep [ this() = $PREP ];

        order %Particle < %Prep < %Det ;
    }

    return gensurface();
}

sub ::inflect_personal_pronoun(num, person, gender, case)
{
    if($num = 1)
    {
        if($person = 1)
        {
            # 'ja maluję' => 'I am painting'
            if($case = nom)
                return "I";

            # 'boli mnie palec' => 'a finger aches me'
            # 'jego obojętność mi przeszkadza' => 'his indifference is disturbing me'
            if($case = acc)
                return "me";

            # 'drukuję swój tekst' => 'I am printing my text'
            if($case = gen or $case = sax)
                return "my";
        }

        if($person = 2)
        {
            # 'ty malujesz' => 'you are painting'
            if($case = nom or $case = acc)
                return "you";

            # 'objąłem stanowisko po tobie' => 'I took over your position'
            if($case = gen or $case = sax)
                return "your";
        }

        if($person = 3)
        {
            if($gender = masc)
            {
                # 'poszedł przed siebie' => 'he went ahead of himself'
                if($case = nom)
                    return "he";

                if($case = acc)
                {
                    warning('UNEXPECTED:: inflect_personal_pronoun - 3masc: acc');
                    return "him";
                }

                # 'Marian kupuje samochód dla swojego syna' => 'Marian is buying the car for his son'
                if($case = gen or $case = sax)
                    return "his";
            }
            else if($gender = fem)
            {
                # 'wyszła po mleko' => 'she left for the milk'
                if($case = nom)
                    return "she";

                # 'Maria kupuje sukienkę dla swojej córki' => 'Maria is buying the dress for her daughter'
                if($case = acc or $case = gen or $case = sax)
                    return "her";
            }
            else if($gender = neut)
            {
                # 'nie miało szczęścia' => 'it wasn~t lucky'
                if($case = nom or $case = acc)
                    return "it";

                # 'dziecko kupuje samochód swojemu rodzicowi' => 'the child is buying the car for its parent'
                if($case = gen or $case = sax)
                    return "its";
            }
            else if($gender = masc_or_neut)
            {
                # 'on pomalował okno' => 'he painted the window'
                if($case = nom)
                    return "he";

                # 'lubię go' => 'I like him'
                if($case = acc)
                    return "him";

                # 'objąłem stanowisko po nim' => 'I took over his position'
                if($case = gen or $case = sax)
                    return "his";
            }
            else if($gender = fem_or_neut)
            {
                # 'ona maluje' => 'she is painting'
                if($case = nom)
                    return "she";

                # 'wszyscy ją lubią' => 'everyone like her'
                if($case = acc or $case = gen or $case = sax)
                    return "her";
            }
            else if($gender = masc_or_fem)
            {
                # 'chmurzy się' => 'he/she is clouding over'
                if($case = nom)
                    return "he/she";

                # 'niech pójdzie z nami' => 'let him/her go with us'
                if($case = acc)
                    return "him/her";

                if($case = gen or $case = sax)
                {
                    # 'osoba działająca we własnym imieniu' => 'person acting in his/her own name'
                    return "his/her";
                }
            }
            else if($gender = masc_or_fem_or_neut)
            {
                # 'lubi malować okno' => 'he likes to paint the window'
                if($case = nom)
                    return "he";

                # 'niech nie kłamie' => 'let him not lie'
                if($case = acc)
                    return "him";

                # 'niech opowie swoją historię' => 'let him tell his story'
                if($case = gen or $case = sax)
                    return "his";
            }

            warning("unknown gender"+$gender);
            return "it";
        }
    }
    else
    {
        if($person = 1)
        {
            # 'poszłyśmy na spacer' => 'we went for a walk'
            if($case = nom)
                return "we";

            # 'nie znajdziecie nas' => 'you won~t find us'
            if($case = acc)
                return "us";

            if($case = gen or $case = sax)
            {
                # 'będziemy mieli go na sumieniu' => 'we will be having him on our conscience'
                return "our";
            }
        }

        if($person = 2)
        {
            # 'graliście w gry' => 'you played games'
            if($case = nom)
                return "you";

            # 'nie znalazłam was' => 'I didn~t find you'
            if($case = acc)
                return "you";

            if($case = gen or $case = sax)
            {
                # 'organizujcie swoje życie' => 'organize your life'
                return "your";
            }
        }

        if($person = 3)
        {
            # 'upiekli ulubione ciasto' => 'they baked the favourite cake'
            if($case = nom)
                return "they";

            # 'poproś ich o pomoc' => 'ask them for help'
            if($case = acc)
                return "them";

            if($case = gen or $case = sax)
            {
                # 'skoncentrowali na sobie uwagę' => 'they fixed their attention on themselves'
                return "their";
            }
        }
    }

    warning("personal pronoun - wrong form");
    return "it";
}

sub ::inflect_reflexive_pronoun(num, person, gender)
{
    if(undefined($num))
    {
        # 'zawstydził samego siebie' => 'he put oneself to shame'
        return "oneself";
    }

    if($num = 1)
    {
        if($person = 1)
        {
            # 'byłam na własnym garnuszku' => 'I fended for myself'
            return "myself";
        }

        if($person = 2)
        {
            # 'byłeś na własnym garnuszku' => 'you fended for yourself'
            return "yourself";
        }

        if($person = 3)
        {
            if($gender = masc)
            {
                # 'skoncentrował się na sobie' => 'he concentrated on himself'
                return "himself";
            }
            else if($gender = fem)
            {
                # 'była na własnym garnuszku' => 'she fended for herself'
                return "herself";
            }
            else if($gender = neut)
            {
                # 'było na własnym garnuszku' => 'it fended for itself'
                return "itself";
            }
            else if($gender = masc_or_neut)
            {
                # 'był na własnym garnuszku' => 'he fended for himself'
                return "himself";
            }
            else if($gender = fem_or_neut)
            {
                # 'ona się lubi' => 'she likes herself'
                return "herself";
            }
            else if($gender = masc_or_fem)
            {
                # 'Nigdy nam się nie objawia' => 'He/she is never revealing himself/herself to us'
                return "himself/herself";
            }
            else if($gender = masc_or_fem_or_neut)
            {
                # 'da sobie spokój' => 'he will leave himself alone'
                return "himself";
            }

            warning("unknown gender"+$gender);
            return "itself";
        }
    }
    else
    {
        if($person = 1)
        {
            # 'daliśmy sobie spokój' => 'we left ourselves alone'
            return "ourselves";
        }

        if($person = 2)
        {
            # 'dajcie sobie spokój' => 'leave yourselves alone'
            return "yourselves";
        }

        if($person = 3)
        {
            # 'skoncentrowali na sobie uwagę' => 'they fixed their attention on themselves'
            return "themselves";
        }
    }

    warning("personal pronoun - wrong form");
    return "oneself";
}


sub PersPron::surface()
{
    # 'lubię Cię' => 'I like you'
    return inflect_personal_pronoun(Num, Person, Gender, Case);
}

sub ReflPron::surface()
{
    # 'on lubi siebie' => 'he likes himself'
    if(Equiv != "each other")
        return inflect_reflexive_pronoun(Num, Person, Gender);
    return gensurface();
}

sub InterrogPron::surface()
{
    if(S = "abstraction")
    {
        # 'co chciałbyś dostać?' => 'what would you like to get?'
        # 'Czego potrzebujesz?' => 'What do you need?'
        return "what";
    }
    else if(S = "person")
    {
        if(Case = nom)
        {
            # 'kto jest z Poznania?' => 'who is from Poznań?'
            return "who";
        }
        else if(Case = acc)
        {
            # 'kogo chcesz spotkać?' => 'whom do you want to meet?'
            return "whom";
        }
        else if(Case = gen or Case = sax)
        {
            warning('UNEXPECTED: InterrogPron - Case = gen or Case = sax');
            return "whose";
        }
    }

    warning("unknown InterrogPron");
    return "";
}

sub DemonsPron::surface()
{
    if(Num = 2)
    {
        # 'wszyscy poszli do kina' => 'everyone went to the cinema'
        if(Equiv = "this")
        {
            warning('UNEXPECTED: DemonsPron - Equiv = "this"');
            return "these";
        }
        else if(Equiv = "that")
        {
            warning('UNEXPECTED: DemonsPron - Equiv = "this"');
            return "those";
        }
    }

    return Equiv;
}

sub U::surface()
{
    # 'procedura sql' => 'sql procedure'
    return Equiv;
}


#!!! TRACE rzeczownik.m

#
#

sub GNP::default()
{
    # specyficzny przypadek - data
    if(find(,day))
    {
        %Day [ label() = day ];
        %OrdDay [ label() = day && cat() = "OrdNum"];
        %Month [ label() = month ];
        %Year  [ label() = year ];

        # '10 maja 2003' => '10 May 2003'
        order %Day < %Month < %OrdDay < %Year;

        if(%OrdDay)
        {
            # 'czwarty kwietnia' => 'April the fourth'
            # 'umarłem czwartego września' => 'I died on September the fourth'
            %OrdDay->insert_before('the',);
        }

        setDef(zero, 100);
        return 0;
    }

    %Head [label() = "#"];
    %Quant [label() = quant];

    if(%Quant)
    {
        if(Num == 2)
        {
            # 'trochę zapałek' => 'a few matches'
            %Quant->set_wc();
        }
        setDef(zero, 100);
    }

    if($apso := find("AP",) and $so := $apso-> find('so',))
    {
        # 'tak szybki samochód' =>  'such a fast car'
        $apso->delete($so,);
        $such := $apso->insert_before("AdjPron",);
        $such->Equiv := "such";
    }

    %AdjPron [ cat() = "AdjPron"];
    %PostAdjPron [ cat() = "AdjPron" && Post];

    %OrdNum[cat() = "OrdNum"];
    %CardNum [cat() = "CardNum"];

    %Compl1 [label() = compl1];
    %Compl2 [label() = compl2];

    %PreAP [cat() = "AP" || cat() = "A"];
    # 'taka czy inna książka' => 'book of one sort or another'
    %PostAP [(cat() = "AP" || cat() = "A") and post()];

    %PossOf [label() = possesive];
    %PossSaxon [label() = possesive && check_saxon()];

    if(semmatch(S,"first_name"))
    {
        # 'koleżanka Marty' => 'Marta~s friend'
        %NonLPPost [ cat() = "NonLP" ];
    }
    else
    {
        # 'Józef Plessogo jest inteligentny' => 'Józef Plessogo is intelligent'
        # 'system Plessogo jest inteligentny' => 'the Plessogo system is intelligent'
        %NonLP [ cat() = "NonLP" ];
    }


    %Number [ cat() = "NonLP" && find("CardNum","#")];

    %CardNum [ cat() = "CardNum" ];
    %PreArticle [ cat() = "CardNum" and Equiv = "half" or label() = "prearticle" ];

    # dla niektórych semantyk przedimek jest mniej prawdopodobny
    # (chyba że odpowiednik jest wieloczłonowy)

    if(not %Head->Equiv =~ /[^ ] [^ ]/ and
       not %PossOf and
       ((semmatch(S,substance) and not semmatch(S,food)) or
        semmatch(S,knowledge_domain) or
        semmatch(S,feeling) or
        semmatch(S,illness)))
    {
        # 'statystyka to dział matematyki' => 'statistics is a branch of mathematics'
        setDef(zero, 50);
    }

    if(%AdjPron)
    {

        # 'taka pogoda' => 'such weather'
        if(%AdjPron->Equiv = "such")
        {
            if(Def = the and Num = 1)
            {
                # 'taki komputer' => 'such a computer'
                setDef(a,80);
            }
            else
            {
                # 'takie komputery' => 'such computers'
                setDef(zero, 100);
            }
        }
        else
        {
            # 'ten komputer' => 'this computer'
            setDef(zero, 100);
        }
    }

    # 'w pokoju 83' => 'in room 83'
    if(%Number)
        setDef(zero, 80);

    # 'Ile masz pieniędzy?' => 'How much money do you have?'
    if(%CardNum)
        setDef(zero, 80);

    if(%PreArticle)
    {
        if(%PreArticle->Def)
        {
            warning('UNEXPECTED: GNP - %PreArticle->Def');
            setDef(%PreArticle->Def,99);
        }
        else if(Num = 1)
        {
            # 'to nie mój kubek' => 'it is not my mug'
            setDef(a, 67);
        }
        else
        {
            # 'to nie moje korale' => 'these are not my beads'
            setDef(zero, 67);
        }
    }

    if(%Head->cat() = "IndefPron")
    {
        # 'ktoś kłamie' => 'somebody is lying'
        order %PreArticle < %Head < %NonLP < %PreAP < %PostAdjPron < %PostAP < %Compl1 < %Compl2 < %PossOf;
    }
    else if(%Head->NonlexPost)
    {
        # 'pokój brata' => 'room of the brother'
        order %PreArticle < %AdjPron < %CardNum < %OrdNum < %PossSaxon < %PreAP < %Head < %NonLP < %NonLPPost < %Number < %PostAdjPron < %PostAP = %PossOf = %Compl1 = %Compl2;
    }
    else
    {
        # 'zawsze mówi prawdę' => 'he always tells the truth'
        order %PreArticle < %AdjPron < %CardNum < %OrdNum < %PossSaxon < %PreAP < %NonLP < %Head < %NonLPPost < %Number < %PostAdjPron < %PostAP = %PossOf = %Compl1 = %Compl2;
    }

    # czasami określoność można wydedukować z przymiotnika
    # 'jestem ostatnim programistą' => 'I am the last programmer'
    # 'lubię najpiękniejsze dziewczęta' => 'I like the most beautiful girls'
    foreach $s
    {
        if(($s->cat() = "AP" or $s->cat() = "AdjPron") and
           $s->Def)
        {
            if($s->Def = "the" or $s->Def = "a" or $s->Def = "zero")
                setDef($s->Def, 67);
            else
                setDef("the", 67);
        }
    }

#
#


    # ustawienie liczebnika "how much"
    if ($cardnum := find("CardNum",) and ($cardnum->Equiv = "how_many" or $cardnum->Equiv = "how many"))
    {
        if (%Head->Num = 1)
        {
            # 'Ile masz pieniędzy?' => 'How much money do you have?'
            $cardnum.Equiv := "how much";
        }
    }
}


sub GNPS::default()
{
    # przy wyliczeniach lepiej nie dostawiać przedimków
    # 'komputer, drukarka, modem' p=>e 'computer, printer, modem'
    # 'futro, sierść' p=>e 'fur, hair'
    if (find(',',) and not with_conjunct())
    {
        setDef("zero", 11);
    }
}

sub CGNP::with_conjunct()
{
    return 1;
}

sub Conj::with_conjunct()
{
    return 1;
}

sub GNPS::with_conjunct()
{
    foreach $s
    {
        if($s->with_conjunct()) {
            return 1;
        }
    }
}

sub GNP::with_conjunct()
{
    foreach $s
    {
        if($s->with_conjunct()) {
            return 1;
        }
    }
}

sub ::with_conjunct()
{
    return 0;
}

#
#
sub AP::correct_pronouns(gnp)
{
    $head := find(,"#");
    if($head->cat() = "VP" and $head->Tense = gerund or
       $head->cat() = "APS")
        $head->correct_pronouns($gnp);
}

sub APS::correct_pronouns(gnp)
{
    foreach $s
    {
        if($s->cat() = "AP")
            $s->correct_pronouns($gnp);
    }
}

sub VP::correct_pronouns(gnp)
{
    if($refl := find("ReflPron",))
    {
        choose_pronoun($gnp, $refl);
    }
}

#

sub GNP::change_case(new_case)
{
        Case := $new_case;

        %Head->change_case($new_case);
}

sub ::change_case(new_case)
{
        Case := $new_case;
}

sub ::check_saxon()
{
    if(Prep = saxon and
       last_son(%Head))
    {
        if(not %Head->Equiv =~ /[ _]/)
        {
            # 'rower Adama' => 'Adam~s bicycle'
            %Head->Case := sax;
            return 1;
        }
        else
        {
            warning('UNEXPECTED: check_saxon()');
            Prep := 'of';
        }
    }

    return 0;
}

sub ::set_wc()
{
    if(%Head->Wc)
        %Head->Equiv := %Head->Wc;
}


#
sub GNP::setDef(def, level)
{
    if(%Head->cat() = "GNPS")
    {
        # 'okulary, szklanka, rękawiczka' => 'glasses, glass, glove'
        return %Head->setDef($def,$level);
    }

    if(DefLevel < $level)
    {
        # 'czwarty czerwiec' => 'the fourth June'
        Def := $def;
        DefLevel := $level;

        return 1;
    }

    if(Def = $def)
    {
        # 'geometria to dział matematyki' => 'geometry is a branch of mathematics'
        return 1;
    }

    return null();
}

sub GNPS::setDef(def, level)
{
    foreach $s
    {
        if(($s->cat() = "GNP" or $s->cat() = "CGNP") and not $s->setDef($def,$level))
        {
            # 'Jaka matka, taka córka' => 'What mother, such a daughter'
            return null();
        }
    }

    return 1;
}

sub CGNP::setDef(def, level)
{
    # 'Adam ma kota i psa' => 'Adam has a cat and a dog'
    foreach $s
    {
        if($s->cat() = "GNP" and not $s->setDef($def,$level))
            return null();
    }

    return 1;
}

#

#!!! TRACE rzeczownik.t

#
#

#

#
#
#

#
#
#

#
#
#
#
#
#
#
#

#
#
#
#
#

#

#
#
#
#

#
#

#
#

#
#

#
#

#
#
#

#
#
#

#
#
#

#
#

#
#

#

sub ::cut_first_in_tinfl(t)
{
    # 'zwierzę czystej rasy' => 'pure-bred animal'
    if($t =~ /^ *[^ ]+ +(.*)$/)
    {
        # 'tkanka wątroby' => 'the liver tissue'
        return $1;
    }
    return $t;
}

sub ::cut_article()
{
    if(Equiv =~ /^the (.+)$/)
    {
        # 'pierwszy program' => 'the first program'
        Def := the;
        DefLevel := 99;
        Equiv := $1;

        Inflection := cut_first_in_tinfl(Inflection);
    }
    else if(Equiv =~ /^(a|an) (.+)$/)
    {
        # 'zdrowy klimat' => 'healthy climate'
        # 'termometr okienny' => 'outdoor thermometer'
        Def := $1;
        DefLevel := 20;
        Equiv := $2;

        Inflection := cut_first_in_tinfl(Inflection);
    }
}

R=>N
{
    'procent' => 'per cent' {warning('UNEXPECTED R: procent');}

    # @attr S - semantyka
    S := get_dvalue(@.S);

    if(@.Sh = 2)
    {
        # 'lubię Instytuty' => 'I like Institutes'
        Upper := 1;
    }

    if(@.Typ = pron)
    {
        # 'kocham panią' => 'I love you'
        change_category("PersPron");
        transfer_to_perspron();
        return 0;
    }

    cut_article();

    if(semmatch(@.S,"surname"))
    {
        # 'Kowalski lubi Nowaka' => 'Kowalski likes Nowak'
        Def := zero;
        DefLevel:= 100;
    }

    if(Def and not DefLevel)
    {
        # 'piątek' => 'Friday'
        DefLevel := 99;
    }

    if(U and not C)
    {
        # 'meble są drogie' => 'furniture is expensive'
        Sg := 1;
    }

    if(Pl)
    {
        # 'ta lornetka była droga' => 'these binoculars were expensive'
        Num := 2;
    }
    else if(Sg)
    {
        # 'te skrzypce są drogie' => 'this violin is expensive'
        # 'skrzypce' => 'violin'
        Num := 1;
    }
    else
    {
        # 'te modemy są drogie' => 'these modems are expensive'
        # 'dwa morderstwa' => 'two murders'
        Num := @.L;
    }

    # 'chcę jeść' => 'I want the food'
    if(Num = nil)
        Num := 1;

    # 'podlać kwiatka' => 'to water the flower'
    if(undefined(Person))
        Person := @.O;

    if(undefined(Gender))
    {
        # 'ten babsztyl jest na własnym garnuszku' => 'this old cow is fending for herself'
        # 'to dziewczę jest na własnym garnuszku' => 'this girl is fending for herself'
        if((@.Rp = ż and semmatch(S,person)) or semmatch(S,female))
        {
            # 'ta programistka lubi siebie' => 'this programmer likes itself'
            # 'ta osoba lubi siebie' => 'this person likes itself'
            # 'ta dziewczyna jest na własnym garnuszku' => 'this girl is fending for herself'
            Gender := fem;
        }
        else if((@.Rp = "mż" or @.Rp = mo) and semmatch(S,person))
        {
            # 'ten programista lubi siebie' => 'this programmer likes himself'
            Gender := masc;
        }
        else
        {
            Gender := neut;
        }
    }


    if(not Def)
    {
        DefLevel := 10;

        if(Num = 2)
        {
            # 'dwie dziewczyny' => 'two girls'
            Def := zero;
        }
        else if(U)
        {
            # 'drogie meble' => 'expensive furniture'
            Def := zero;
            DefLevel := 70;
        }
        else
        {
            # 'moje skrzypce' => 'my violin'
            Def := the;
        }
    }
}

#
sub ::last_son(d)
{
    foreach $s
    {
        if($met)
            return 0;

        if($s = $d)
            $met := 1;
    }

    if(not $met)
        return 0;

    return 1;
}

#
sub ::only_son(d)
{
    $r := 1;
    $found := 0;

    foreach $s
    {
        if($s != $d)
            $r := 0;
        else
            $found := 1;

    }

    if(not $found)
    {
        warning($d + " is not a son of " + this());
        return 0;
    }

    return $r;
}

#
sub ::zero_eng_inflection(e)
{
    # kolejno odrywamy wyrazy...
    # @todo uwzględnić inne znaki interpunkcyjne
    if($e =~ /^([^, ]+)(.*)$/ or $e =~ /^(,)(.*)$/)
    {
        $er := $2;
        return zero_eng_inflection($er) + " 0";
    }
    else
    {
        return "";
    }
}


sub ::insert_measure_word(mw)
{
    # 'kupiłem dwa nowe meble' => 'I bought two new pieces of furniture'
    # 'te trzy lornetki są drogie' => 'these three pairs of binoculars are expensive'
    # 'meble są drogie' => 'furniture is expensive'
    %Head->Inflection := "N! 0" + zero_eng_inflection(%Head->Equiv);
    %Head->Equiv := $mw + " of " + %Head->Equiv;

    Num := 2;
    %Head->Num := 2;
    U := null();
    %Head->U := null();
    Sg := null();
    %Head->Sg := null();
    Pl := null();
    %Head->Pl := null();
}


FR=>GNP
{
    # 'pisanie zdania' => 'writing the sentence'
    :dop1=>:compl1 {}
    # 'mówienie Markowi o Dorocie' => 'telling Marek about Dorota'
    :dop2=>:compl2 {}
    # 'komputer brata' => 'computer of the brother'
    :dopełniacz=>:possesive {}
    # 'Widzę prof. Nowaka.' => 'I can see Prof. Nowak.'
    :apoz=>:appos {}
    '$który' => 'which' {warning('UNEXPECTED: FR: which');}
    '$jaki' => 'what' {warning('UNEXPECTED: FR: what');}
    '$czyj' => 'whose' {warning('UNEXPECTED: FR: czyj');}
    '$ile' => 'how much' {warning('UNEXPECTED: FR: ile');}
    # 'wiedział o tym, że się spotkają' => 'he knew about the fact that they would meet'
    '$to' => ItPron { Equiv := "it";}
    # 'sobie nawzajem' => 'for each other'
    'nawzajem'=>'mutually' {}
    'nie'=>'not' {warning('UNEXPECTED: FR: nie');}
    # 'na pewno nie kino' => 'certainly not a cinema'
    :partykuła => :prearticle {}
    # 'trochę zapałek' => 'a few matches'
    :kwant => :quant {}
    # 'pomiędzy mną a tobą' => 'between me and you'
    # 'pomiędzy mną i tobą' => 'between me and you'
    'a' => 'and' {}
    'i' => 'and' {}
    # MW błąd tłumaczenia: ten, co go odwiedziłam => the one I visited 'that'
    'co' => AdjPron{Equiv := 'that'; warning('UNEXPECTED: FR: co');}

    delete('r.',);
    delete("N","word_year");

    inherit("Interrogative",);
    inherit("Neg",);
    inherit("Gender",);

    S := get_dvalue(@.S);

    # 'mała papuga' => 'small parrot'
    %Head [ label() = "#" ];

    if(%Head->cat() = "GNPS")
    {
        # 'zielone korale, biała bluzka, czerwone spodenki' => 'green beads, white blouse, red shorts'
        Num := 2;
        Person := 3;

        if(%Head->find("CGNP",)->find("Conj",)->Neg)
        {
            # 'nie lubię ani Kamila, ani Karoliny' => 'I like neither Kamil, nor Karolina'
            Neg := 1;
        }
    }
    else
    {
        # 'biała bluzka' => 'white blouse'
        if(%Head)
        {
            # 'okno zostało pomalowane' => 'the window was painted'
            Def := %Head->Def;
            DefLevel := %Head->DefLevel;

            SpecDef := %Head->SpecDef;
            SpecPrep := %Head->SpecPrep;
            SpecCat := %Head->SpecCat;

            Num := %Head->Num;
            Person := %Head->Person;

if(undefined(Compl1) and %Head->Compl1)
            {
                # 'pisanie listu' => 'writing a letter'
                Compl1 := %Head->Compl1;
                Prep1  := %Head->Prep1;
                Def1   := %Head->Def1;
            }
if(undefined(Compl2) and %Head->Compl2)
            {
                # 'pisanie listu' => 'writing a letter'
                Compl2 := %Head->Compl2;
                Prep2  := %Head->Prep2;
                Def2   := %Head->Def2;
            }

            U := %Head->U;

            # @attr Mw - "measure word", tj. wyraz używany gdy rzeczownikowi towarzyszy
            # liczebnik główny
            # 'sześć mebli' => 'six pieces of furniture'
            Mw := %Head->Mw;
        }
        else
        {
            # 'było to w roku 2010, w maju' => 'it was in 2010, in May'
            Def := zero;
            DefLevel := 15;
            Num := @.L;
            Person := @.O;

            find(,year)->Case := nom;
            find(,year)->Prep := null();
        }
    }

    if(Mw and find("CardNum",) and %Head->eqv()->L = 2)
    {
        # 'sześć mebli' => 'six pieces of furniture'
        insert_measure_word(Mw);
    }

    # jeśli z głową nie były związane atrybuty Num i Person
    # (np. dla akronimów)
    # 'PCXY kocha was' => 'PCXY loves you'
    if(undefined(Num))
        Num := @.L;

    if(undefined(Person))
        Person := @.O;

    # zabezpieczamy się przed dziwnymi przypadkami, kiedy Num/Person
    # pozostaje dalej nieustawione
    if(not Num)
        Num := 1;

    # 'rok w którym urodziłam się' => 'year in which I was born'
    if(not Person)
        Person := 3;

    if(%Head->cat() = "AdjPron")
    {
        if(%Head->Equiv = "this")
        {
            if(Num == 2)
            {
                # 'ci, którzy lubią ten taniec' =>? 'the ones which like this dance'
                %Head->Equiv := "the ones";
            }
            else
            {
                # 'ten, który lubi ten taniec' =>? 'the one which likes this dance'
                # 'ten, kto lubi ten taniec' =>? 'the one which likes this dance'
                # 'lubię tego, kto zaśpiewa' => 'I like the one who will sing'
                %Head->Equiv := "the one";
            }

            %Head->Inflection := "";
            Def := the;
            DefLevel := 100;
        }
        else if(%Head->Equiv = "no")
        {
            # 'żaden z nas nie lubi pająków' => 'none of us likes spiders'
            %Head->Equiv := "none";
            %Head->Inflection := "";
            Def := zero;
            DefLevel := 100;
        }
    }
    else if(%Head->cat() = "ItPron" and find("VP",))
    {
        # 'Anna lubi to, co ja lubię' => 'Anna likes what I like'
        %Head->delete('what',);
        %Head->insert_right('',"#");
    }
    # zaimki typu "sam siebie"
    else if(%Head->cat() = "ReflPron" and $adjpron := find("AdjPron",))
    {
        # poniższy zapis jest specyficznie związany z dziwnym drzewem zaimka "sam"
        # 'pluję na samego siebie' => 'I am spitting on myself'
        # 'programista nie lubi samego siebie' => 'the programmer doesn~t like himself'
        if ($adjpron->find("AdjPron",)->find('$sam',))
            delete($adjpron,);
    }

    # uzgodnienie liczby zaimków this/that
    foreach $s
    {
        # 'tamte boginie' => 'those goddesses'
        if($s->cat() = "AdjPron")
            $s->Num := Num;
    }

    if(@.P = mian)
    {
        # 'on' => he
        # 'samochody' => 'cars'
        # 'drukarki' => 'printers'
        # 'Polacy' => 'Poles'
        Case := nom;
        Prep := null();
    }
    else if(@.P = dop)
    {
        # 'samochodów' => 'of cars'
        # 'drukarek' => 'of printers'
        # 'mebli' => 'of furniture'
        Case := gen;
        Prep := 'of';
    }
    else if(@.P = cel)
    {
        # 'samochodom' => 'for cars'
        # 'i Polakom' => 'and for Poles'
        # 'meblom' => 'for furniture'
        Case := acc;
        Prep := 'for';
    }
    else if(@.P = bier)
    {
        # 'jemu' => 'for him'
        # 'Joannę' => 'Joanna'
        # 'drukarkę' => 'printer'
        Case := acc;
        Prep := null();
    }
    else if(@.P = narz)
    {
        Case := acc;

        if(semmatch(%Head->S,"vehicle"))
        {
            if(eqv()->Length = 1)
            {
                # 'samochodami' => 'by cars'
                Prep := 'by';
                setDef(zero,100);
            }
            else
            {
                # 'samochodami osobowymi' => 'on passenger cars'
                Prep := 'on';
            }
        }
        else
        {
            # 'policjantami' => 'with police officers'
            # 'przyjaciółmi' => 'with friends'
            Prep := 'with';
        }
    }
    else if(@.P = miejsc)
    {
        # 'samochodach' => 'cars'
        # 'policjantach' => 'police officers'
        Case := acc;
        Prep := null();
    }
    else if(@.P = woł)
    {
        # 'Joanno' => 'Joanna'
        Case := acc;
        Prep := null();
    }

    # obsługa przydawki dopełniaczowej
    if($poss := find("GNP",possesive))
    {
        # obsługa transferu przydawki dopełniaczowej na coś innego niż "of NP"
        if(0)   # (sztuczka do 'else if' w makrze repeat)
            0;
else if(%Head->eqv()->Sem1 and not %Head->eqv()->Dop1 and Prep1 != "of")
        {
            # 'rada banku' => 'council of the bank'
            # 'magazyn amunicji' => 'magazine of the ammunition'
            $poss->change_label(compl1);
        }
else if(%Head->eqv()->Sem2 and not %Head->eqv()->Dop2 and Prep2 != "of")
        {
            # 'rada banku' => 'council of the bank'
            # 'magazyn amunicji' => 'magazine of the ammunition'
            $poss->change_label(compl2);
        }
        else if(semmatch(($poss->find(,"#")).S,"first_name") and $poss->last_son($poss->find(,"#")) and not find("AdjPron",))
        {
            # 'rower Adama' => 'Adam~s bicycle'
            $poss.Prep := saxon;
        }
    }

    # frazy typu "siebie nawzajem"
    if (find('mutually',))
    {
        # 'myślą o sobie nawzajem' => 'they are thinking about each other'
        find("ReflPron","#")->Equiv := "each other";
        delete('mutually',);
    }

    # TRANSFER DOPEŁNIEŃ

if($COMPL := find(,compl1))
    {
        if($COMPL.cat() = "GNP")
        {
            # @todo poprawić, żeby wychodziło "scanner service"

            # NPf idzie na koniec:
            # 'rozkaz zabicia tego smoka' p=>e 'order to kill this dragon'
            if (not Prep1 and not find("V", "#") and Compl1 != "NPf")
            {
                # 'automat z sokiem' p=>e 'juice vending machine'
                # 'komisariat Poznań Jeżyce' p=>e 'Poznań Jeżyce police station'
                $COMPL.Prep := of;
            }
            else
            {
                # 'zależność od tego wyniku' => 'dependence on this result'
                $COMPL.Prep := Prep1;
            }

            # @todo ??? co to jest
            # MW Dopełnienie ze zdaniem podrzędnym rozbijane jest na dwa drzewa.
            if ($COMPL->find ("SubC", "#"))
            {
                warning('UNEXPECTED: FR - $COMPL->find ("SubC", "#")');
                if ($COMPL.Prep != '' and SubC.Type != ob)
                    SubC.Type := gerund;
            }

        }
        else if($COMPL.cat() = "AdvP")
        {
            # 'ich obecność tutaj' => 'their presence here'
            # @todo ???
            if(Compl1 = "AJ")
            {
                warning('UNEXPECTED: FR - Compl1 = "AJ"');
                $COMPL.Adj := true;
            }
        }
        else if($COMPL.cat() = "SubC" or $COMPL.cat() = "VP")
        {
            # 'rozkaz zabicia tego smoka' => 'order to kill this dragon'
            $COMPL.delete("Prep",);

            $COMPL.Type := Compl1;
            $COMPL.Prep := Prep1;
        }
    }
if($COMPL := find(,compl2))
    {
        if($COMPL.cat() = "GNP")
        {
            # @todo poprawić, żeby wychodziło "scanner service"

            # NPf idzie na koniec:
            # 'rozkaz zabicia tego smoka' p=>e 'order to kill this dragon'
            if (not Prep2 and not find("V", "#") and Compl2 != "NPf")
            {
                # 'automat z sokiem' p=>e 'juice vending machine'
                # 'komisariat Poznań Jeżyce' p=>e 'Poznań Jeżyce police station'
                $COMPL.Prep := of;
            }
            else
            {
                # 'zależność od tego wyniku' => 'dependence on this result'
                $COMPL.Prep := Prep2;
            }

            # @todo ??? co to jest
            # MW Dopełnienie ze zdaniem podrzędnym rozbijane jest na dwa drzewa.
            if ($COMPL->find ("SubC", "#"))
            {
                warning('UNEXPECTED: FR - $COMPL->find ("SubC", "#")');
                if ($COMPL.Prep != '' and SubC.Type != ob)
                    SubC.Type := gerund;
            }

        }
        else if($COMPL.cat() = "AdvP")
        {
            # 'ich obecność tutaj' => 'their presence here'
            # @todo ???
            if(Compl2 = "AJ")
            {
                warning('UNEXPECTED: FR - Compl2 = "AJ"');
                $COMPL.Adj := true;
            }
        }
        else if($COMPL.cat() = "SubC" or $COMPL.cat() = "VP")
        {
            # 'rozkaz zabicia tego smoka' => 'order to kill this dragon'
            $COMPL.delete("Prep",);

            $COMPL.Type := Compl2;
            $COMPL.Prep := Prep2;
        }
    }

    # transfer fraz rzeczownikowych typu 'to ja grałem'
    RO => CLEFT
    {
        # 'to ten człowiek zabił Adama' => 'it was this man that killed Adam'
        'to' => 'it is' {}
    }

    # frazy typu 'ile koni'
    # 'ile samochodów kupiłeś wczoraj?' => 'how many cars did you buy yesterday?'


    # @todo chyba do wyrzucenia
    if(Num = 2 and delete('how much',))
    {
        warning('UNEXPECTED: FR - Num = 2 and delete(how much,)');
        insert_left('how many',);
    }

    # @todo upewnić się co do tłumaczenia zdań 'to, jak umarł'
    if ($ip := find("ItPron","#") and ($subc := find("SubC",) or find("VP",) or find("CVP",)))
    {
        # 'to, że umarł wczoraj' => 'the fact that he died yesterday'
        $ip.Equiv := "";
        if ($subc->Type = that)
            $ip.Equiv := "the fact that";
    }

    # 'pięciu z nich zna Adama' => 'five of them know Adam'
    if (find("CardNum",) and find("SP","#"))
	    Num := 2;
}

#
SFR=>GNPS
{
    # pozbywamy się przyimków ze składników (wystarczy jeden przyimek przed
    # całym szeregiem)

    # 'nienawidzę Adama, Anny i Roberta' => 'I hate Adam, Anna and Robert
    # 'nie chcę ani komputerów, ani drukarek, ani modemów' => 'I want neither computers nor printers nor modems'
    foreach $S
    {
        if($S->cat() = "CGNP")
            $S->find("GNP",)->Prep := null();
        else
            $S->Prep := null();
    }

    # 'chcę albo Annę, albo Marię' => 'I want either Anna or Maria
    if($Prep1 := find("CGNP",)->find("Conj",)->Prep1)
    {
        foreach $S
        {
            if ($Conj:= $S->find("Conj",) and ($Conj->eqv()->Ps1 = 8 or $Conj->eqv()->Ps1 = 9))
            {
                if ($Prep1 = "0")
                {
                    warning('UNEXPECTED: SFR - $Prep1 = 0');
                    $Conj->Equiv := "";
                }
                else
                    $Conj->Equiv := $Prep1;
            }
        }
    }
}

FRs=>CGNP {}

FS=>SP
{
    # 'jeden z nich' => 'one of them'
    $Prep := find("Prep",);
    if($Prep)
    {
        $P := "of";
        delete($Prep,);
        find(,)->Prep := $P;
    }
}

W=>N
{
    # 'system Plessogo' => 'Plessogo system'
    Num := 1;
    Person := 3;

    Gender := neut;

    S := get_dvalue("abstraction, artifact, organization");

    Def := zero;
    DefLevel := 66;
}

N=>U {}

FN=>NonLP {}

A=>ACR {}

#

sub ::transfer_to_perspron()
{
    Num := @.L;
    # 'ona i on' => 'she and he'
    if(undefined(Person))
        Person := @.O;

    if(Num = 1 and Person = 3)
    {
        S := any;

        if(@.R = n or Equiv = it)
        {
            # 'ono' => 'it'
            Gender := neut;
        }
        else if(@.R = mż or @.R = mnż or @.R = mo)
        {
            # 'on jest punktualny' => 'he is punctual'
            Gender := masc_or_neut;
        }
        else
        {
            # 'ona jest punktualna' => 'she is punctual'
            Gender := fem_or_neut;
        }
    }
    else if(Num = 2 and Person = 3)
    {
        # 'oni są punktualni' => 'they are punctual'
        S := any;
    }
    else
    {
        # 'czy ty mnie słuchasz' => 'whether you are listening to me'
        S := person;
    }

    if(@.P = mian)
    {
        # 'ona jest w domu' => 'she is at home'
        Case := nom;
    }
    else
    {
        # 'lubię go' => 'I like him'
        Case := acc;
    }
    Def := zero;
    DefLevel := 100;
}

ZRo => PersPron
{
    # 'on i ona' => 'he and she'
    transfer_to_perspron();
}

ZRp => InterrogPron
{
    # 'kto kłamie?' => 'who is lying?'
    # 'kogo nie lubisz?' => 'whom don~t you like?'
    # 'czego nie lubisz' => 'of what you are disliking'
    # 'co chciałbyś dostać?' => 'what would you like to get?'
    Num := @.L;
    Person := @.O;

    if(@.P = mian)
        Case := nom;
    else
        Case := acc;

    if(@.Typ = co)
        S := "abstraction";
    else if(@.Typ = kto)
        S := "person";
    else
    {
        # 'lista fragmentów, cóż innego' => 'list of fragments, other'
        warning("unknown Typ for ZRp:"+@.Typ);
    }
    Interrogative := 1;

    Def := zero;
    DefLevel := 100;
}

ZRw => DemonsPron
{
    Num := @.L;
    Person := 3;

    if(@.P = mian)
    {
        # 'wszyscy poszli do kina' => 'everyone went to the cinema'
        Case := nom;
    }
    else
    {
        # 'mówię do wszystkich' => 'I am talking to everyone'
        Case := acc;
    }

    Def := zero;
    DefLevel := 100;
}

ZRn => IndefPron
{
    Num := @.L;
    Person := 3;

    if(@.P = mian)
    {
        # 'ktoś kłamie' => 'somebody is lying'
        Case := nom;
    }
    else
    {
        # 'kogoś spotkam' => 'I will meet somebody'
        Case := acc;
    }
    S := @.S;

    Def := zero;
    DefLevel := 100;
}

ZRs => ReflPron
{
}

#

#!!! TRACE slots.t

#
#
#
#
#

FRAG => FRAG {
}



sub ::tfrag(f)
{
    if($f and $f =~ /[^ ]/)
    {
        $fn := insert_right("TFRAG",);
        $fn->Equiv := $f;
    }
}

sub ::tslot(s,i)
{
    if(not $i)
    {
        warning("reference to a non-existining slot");
        return 0;
    }

    $sslot := find(,"slot"+$i);

    if(not $sslot)
    {
        warning("reference to a non-existining slot");
        return 0;
    }

    delete($sslot,);

    $sn := insert_right($sslot,);
    $sslot->change_label("slot"+$i);
    $sslot->TCat := $s;

    if($s =~ /^NP[ng]?$/)
    {
        $sslot->Prep := none;

        if($s = "NPn")
        {
            warning('UNEXPECTED: $s = "NPn"');
            $sslot->Case := nom;
        }
        else if($s = "NPg")
        {
            # 'objąłem stanowisko po Adamie' => 'I took over Adam~s position'
            $sslot->change_case(sax);
            $sslot->Prep := saxon;
        }
        else
        {
            # @todo nom?
            $sslot->Case := acc;
        }
    }
    else if($s =~ /^NUM_([NGDAIL])$/)
    {
        warning('UNEXPECTED: $s =~ /^NUM_([NGDAIL])$/');
        $sslot->P := $1;
    }
    else if($s = "TH" or $s = "TO" or $s = "IN" or $s = "RC" or
            $s = "GR")
    {
        # 'nie każdego stać na abonowanie tego dwutygodnika' => 'not everyone is capable of subscribing to this fortnightly magazine'
        $sslot->Type := $s;
        $sslot->clear("Prep");
        $sslot->Prep := "";
    }

}

#
#
#
sub ::getslotnb(i)
{
    if($i = 1)
    {
        if(@.Oblig1 = slot)
            return 1;

        if(@.Oblig2 = slot)
        {
            warning('UNEXPECTED: @.Oblig2 = slot');
            return 2;
        }
        if(@.Oblig3 = slot)
        {
            warning('UNEXPECTED: @.Oblig3 = slot');
            return 3;
        }
    }
    else if($i = 2)
    {
        if(@.Oblig1 = slot and @.Oblig2 = slot)
        {
            # 'trwały od 15 miesięcy do ośmiu lat' => 'they lasted from 15 months to eight years'
            return 2;
        }
        if((@.Oblig1 = slot or @.Oblig2 = slot) and @.Oblig3 = slot)
        {
            warning('UNEXPECTED: (@.Oblig1 = slot or @.Oblig2 = slot) and @.Oblig3 = slot');
            return 3;
        }
    }
    else if($i = 3 and @.Oblig1 = slot and @.Oblig2 = slot and @.Oblig3 = slot)
    {
        warning('UNEXPECTED: $i = 3 and @.Oblig1 = slot and @.Oblig2 = slot and @.Oblig3 = slot');
        return 3;
    }

    return $i;
}

#
#
sub ::tfrags(e,i)
{
#
    if($e =~ /^(([^\$]|\$([^ABCDEFGHIJKLMNOPQRSTUVWXYZ][^\$]+)\$)*)\$([ABCDEFGHIJKLMNOPQRSTUVWXYZ][^\$]+)\$(.*)/)
    {
        tfrag($1);
        $n := $i;
        $c := $4;
        $r := $5;
        if($c =~ /^(.*)\[([123])\]$/)
        {
            warning('UNEXPECTED: $c =~ /^(.*)\[([123');
            $c := $1;
            $n := atoi($2);
        }
        tslot($c,getslotnb($n));
        $i := $i + 1;
        tfrags($r, $i);
    }
    else
    {
        # 'absolutnie nic sobie nie robi z zakazów' => 'completely he is ignoring bans completely'
        tfrag($e);
    }
}

#
#
sub ::delfrags()
{
    if(delete("FRAG",))
        delfrags();
}

sub ::slots()
{
    if(@.Frag)
    {
        # 'w odpowiedzi na pismo z dnia piątego maja' => 'in response to the letter dated May the fifth'
        if(parent()->cat() = "N")
            cut_article();

        # usuwamy fragmenty z drzewa źródłowego
        delfrags();
        # Equiv "rozbieramy" na fragmenty i sloty
        tfrags(Equiv,1);
        clear("Equiv");
        $H := find(,"#");
        delete($H,);
    }
}

OTH=>OTH
{
    # 'w Michała jakby piorun strzelił' => 'Michał went berserk'
    :slot1 => :slot1 {}
    # 'trwały od 15 miesięcy do ośmiu lat' => 'they lasted from 15 months to eight years'
    :slot2 => :slot2 {}
    :slot3 => :slot3 {warning('UNEXPECTED: OTH - slot3');}

    slots();
}

#!!! TRACE spojnik.t

#

#
S => Conj
#
{
    # 'toteż' => 'therefore'
    Num := @.L;
    Person := @.O;
}

SPÓJNIK_OD => Conj
{
    # 'szybszy ode mnie' => 'faster than me'
    # 'szybszy od wiatru' => 'faster than the wind'
    'od' => 'from' {}
    'ode' => 'from' {}

    NoPrep := 1;
}


SPÓJNIK_SPOŚRÓD => Conj
{
    warning('UNEXPECTED: SPÓJNIK_SPOŚRÓD');
    'z' => 'of' {}
    'ze' => 'of' {}
    'spośród' => 'of' {}
}





#!!! TRACE zdania.i

#

sub RelC::surface()
{
    # 'wszyscy, którzy przyszli do kina byli młodzi' => 'everyone which came to the cinema were young'
#
    if(Type = non_defining)
    {
        warning('UNEXPECTED: Type = non_defining');
        insert_left(",","punct");
        insert_right(",","punct");
    }

    return gensurface();
}

sub SubC::surface()
{
    # 'chcę kupić, żebym nie musiała pożyczać' => 'I want to buy so that I not have to lend'
    if(Prep and Prep != none)
    {
        $PREP := insert_left("Prep",);
        $PREP->Equiv := strip_quotes(Prep);
    }

    return gensurface();
}

#!!! TRACE zdania.m

#

#

sub ::set_future_to_present()
{
    if (Time = future)
        Time := present;
    else if (Time = future_continuous)
        Time := present_continuous;
}

sub ::set_no_negation()
{
    Neg := 0;
    if (Time = future)
    {
        Time := present;
    }
    else if (Time = future_continuous)
    {
        Time := present_continuous;
    }
}

sub:: set_as_if()
{
    Person := 3;
    Num := 2;
}


sub CVP::future_to_present()
{
    set_future_to_present();
    %Head->set_future_to_present();
}

sub VP::future_to_present()
{
    set_future_to_present();
    %Head->future_to_present();
}

sub V::future_to_present()
{
    set_future_to_present();
}


sub CVP::no_negation()
{
    set_no_negation();
    %Head->no_negation();
}

sub VP:: no_negation()
{
    set_no_negation();
    %Head->no_negation();
}

sub V:: no_negation()
{
    set_no_negation;
}

sub VP::as_if()
{
    %Head->as_if();
}

sub ::unify_gender(a,b)
{
    # 'poprosiłam ją, żeby odpoczęła' => 'I asked her to rest'
    if($a = $b)
        return 1;

    if($a = masc_or_fem_or_neut)
    {
        warning('UNEXPECTED: unify_gender $a = masc_or_fem_or_neut');
        return $b;
    }
    if($b = masc_or_fem_or_neut)
    {
        warning('UNEXPECTED: unify_gender$b = masc_or_fem_or_neut');
        return $a;
    }

    # 'powiedział, żeby dał sobie spokój' => 'he told to leave himself alone'
    if($a = masc_or_neut and ($b = masc or $b = neut))
        return $b;

    # 'powiedziała, żeby dała sobie spokój' => 'she told to leave herself alone'
    if($a = fem_or_neut and ($b = fem or $b = neut))
        return $b;

    if($a = masc_or_fem and ($b = masc or $b = fem))
    {
        warning('UNEXPECTED: unify_gender$a = masc_or_fem and ($b = masc or $b = fem)');
        return $b;
    }

    # 'prosił, żeby nie przyszło' => 'he asked not to come'
    if($b = masc_or_neut and ($a = masc or $a = neut))
        return $a;

    # 'poprosiła, żeby przyszło' => 'she asked to come'
    if($b = fem_or_neut and ($a = fem or $a = neut))
        return $a;

    # 'poprosił, żeby nie przyszło' => 'he asked not to come'
    if($b = masc_or_fem and ($a = masc or $a = fem))
        return $a;

    return 0;
}


sub ::pronoun_compatible(p,c)
{
    if($p.Num = $c.Num and $p.Person = $c.Person)
    {
        if($p.Person = 3 and $p.Num = 1)
        {
            # 'poprosiłam ją, żeby odpoczęła' => 'I asked her to rest'
            if($ph := $p->find(,"#") and
               $ch := $c->find(,"#") and
               unify_gender($ph.Gender,$ch.Gender))
            {
                return 1;
            }
            else
            {
                # 'powiedziała, żeby był na własnym garnuszku' => 'she told him to fend for himself'
                return 0;
            }
        }

        return 1;
    }

    return 0;
}

sub VP::erase_subject()
{
    # 'przekonałem ludzi, żeby nie palili' => 'I convinced people not to smoke'
    $S := find(,subject);

    # 'poprosiła mnie o zastąpienie jej, żeby pojechać nad morze' => 'she asked me for replacing her to go to the seaside'
    if(not $S)
        return 0;

    $p := parent();

    if($p->cat() = "SubC")
        $p := $p->parent();

    if($S->find("PersPron","#"))
    {
        if($p->cat() = "VP" and
           $pS := $p->find("GNP",subject) and
           pronoun_compatible($S, $pS))
        {
            # 'poprosiła mnie o opiekę nad dzieckiem, żeby sama odpoczęła' => 'she asked me for the child care alone to rest'
            delete($S,);
            $S := 0;
        }
        else if($pC := $p->find("GNP",compl3))
        {
            warning('UNEXPECTED: errase_subject $pC := $p->find("GNP",compl3)');
            if(pronoun_compatible($S, $pC))
            {
                warning('UNEXPECTED: errase_subject pronoun_compatible($S, $pC)');
                delete($S,);
                $S := 0;
            }
        }
        else if($pC := $p->find("GNP",compl2))
        {
            warning('UNEXPECTED: errase_subject $pC := $p->find("GNP",compl2)');
            if(pronoun_compatible($S, $pC))
            {
                warning('UNEXPECTED: errase_subject $pC := $p->find("GNP",compl2) -> pronoun_compatible($S, $pC)');
                delete($S,);
                $S := 0;
            }
        }
        else if($pC := $p->find("GNP",compl1))
        {
            if(pronoun_compatible($S, $pC))
            {
                delete($S,);
                $S := 0;
            }
        }
    }

    return $S;
}

sub SubC::default()
{
    $VP := find("VP",);

    # 'Kopernik udowodnił, że Ziemia obraca się wokół Słońca' => 'Kopernik proved, that the Earth revolves around the Sun'
    if(not $VP)
        return 0;

    if(Type = "TO")
    {
        $S := $VP->erase_subject();

        # podmiot nie został wymazany
        if($S)
        {
            $S->change_case(acc);

            if(parent()->cat() = "VP")
            {
                # 'poprosiłam, żeby przyszli wieczorem' => 'I asked them to come during the evening'
                if(parent()->find("GNP",compl1) or
                   parent()->find("GNP",compl2) or
                   parent()->find("GNP",compl3))
                {
                    warning('UNEXPECTED: SubC - parent()->find("GNP",compl1 ... poprosił Karola, bym mogła zostać');
                    $S->Prep := "for";
                }
            }
            else
            {
                # 'pokusa byśmy zagrali' => 'temptation for us to play'
                $S->Prep := "for";
            }
        }

        $VP->set_tense(to_infinitive);
    }
    else if(Type = "GR")
    {
        # 'nie każdego stać, żeby abonować ten dwutygodnik' => 'not everyone can afford subscribing to this fortnightly magazine'
        $S := $VP->erase_subject();

        # podmiot nie został wymazany
        if($S)
        {
            warning('UNEXPECTED: Type = "GR" - $s');
            $S->change_case(acc);
        }

        $VP->set_tense(gerund);
    }
    else if(Type = "IN")
    {
        # 'nie pozwoli, żeby przemalować pokój' => 'he won~t let repaint the room'
        $S := $VP->erase_subject();

        # podmiot nie został wymazany
        if($S)
        {
            # 'nie pozwoli, żeby Tomasz przemalował pokój' => 'he won~t let Tomasz repaint the room'
            $S->change_case(acc);
        }

        $VP->set_tense(infinitive);
    }
    else if(Type = "TH")
    {
#
#
#
#

        if($VP->Tense != to_infinitive)
        {
            # 'liczę, że pojadę do Poznania' => 'I hope that I will go to Poznań'
            Prep := "that";
        }
    }
    else if(Type = "so_that")
    {
        # 'chciałabym, żebyś mógł zostać' => 'I would like so that you can stay'
        Prep := "so that";
    }
    else if(Type = how)
        # 'kwiecień, jak powiedziałeś' => 'April how, you said'
        Prep := "how";
    else if(Type = "in_order_to")
    {
        # 'na tyle inteligentny, by odejść' => 'enough intelligent in order to walk away'
        if(find("VP",)->Tense = to_infinitive)
        {
            Prep := "in order";
        }
        else
        {
            warning('UNEXPECTED: else find("VP",)->Tense = to_infinitive');
            Prep := "in order to";
        }
    }
    else if(Type = "SH")
    {
        # 'trzeba, żeby kupić ten samochód' => 'it is necessary to buy this car'
        if(not $VP->find("GNP",subject))
        {
            # 'Sugerujemy, aby nie nadużywać' => 'We are suggesting not to abuse'
            $VP->set_tense(to_infinitive);
        }
        else
        {
            warning('UNEXPECTED: else not $VP->find("GNP",subject)');
            # MW 'trzeba, żebyśmy kupili samochód' => 'it is necessary we should buy this car'
            $VP->set_tense(subjunctive);
        }
    }
}



#!!! TRACE zdania.t

#

#
#

Z=>S
{
    # 'Poszłam na spacer.' => 'I went for a walk.'
    # 'Kiedy pójdziesz na spacer?' => 'When will you go for a walk?'
    if(@.Pytanie)
    {
        if (find("VP",)->Tense != imperative)
            find(,)->Question := 1;
    }
}

Z0=>S
{

}

ZS=>InterrogPart
{
    # 'Kiedy pójdziesz na spacer?' => 'When will you go for a walk?'
    Interrogative := 1;
}

#
#
#
#
#
#

    if (@.Typ = to)
    {
        $BE := insert_left("V","#");
        $BE.Equiv := 'be';

        $v->Be := 1;
        $v->Stat := 1;

        $BE.Tense := Tense;
        $IT := insert_left("NomPron", subject);
        $IT.Person := 3;
        $IT.Num := 1;
        $IT.Gender := neut;
        $IT.Equiv := "";
#
        $GNP := find("GNP",subject);
        if ($P := $GNP->find("CLEFT",) and $P.cat() = 'it is')
        {
            $GNP->find("NP",);
            warning("CLEFTING NOT DONE");

#
#
        }
    }
#


KORELAT => CORRELATE
{
    # 'chromolić to, że jest słaby' => 'to not give a toss that he is weak'
    # 'założyłam się o to, że umyję samochód' => 'I bet that I would clean the car'
    # 'zważaj na to, że jest gorąco' => 'pay heed that there is a heat'
    # 'błogosławił za to, że przyszli' => 'he blest for them coming'
    # 'ubolewam nad tym, że się spóźniłam' => 'I regret being late'
    # 'znany z tego, że jest wesoły' => 'well-known for him being cheerful'

    #Wstępny transfer cząstek korelatów
    'to'=> 'what' {}
    'tego'=> 'what' {}
    'tym'=> 'what' {}
    'temu'=> 'what' {warning('UNEXPECTED: KORELAT - temu');}
    'o'=> 'about' {}
    'na' => 'for' {}
    'za' => 'for' {}
    'nad' => 'over' {}
    'w' => 'in' {warning('UNEXPECTED: KORELAT - w');}
    'z' => 'from' {}
    'do' => 'to' {warning('UNEXPECTED: KORELAT - do');}

    if(@.Typ = to)
        Type = what;
    else if (@.Typ = o_to)
        Type = for;
    else if (@.Typ = na_to)
        Type = for;
    else if (@.Typ = za_to)
        Type = for;
    else if (@.Typ = nad_tym)
        Type = over;
    else if (@.Typ = na_tym)
    {
        warning('UNEXPECTED: KORELAT - @.Typ = na_tym');
        Type = on;
    }
    else if (@.Typ = o_tym)
    {
        warning('UNEXPECTED: KORELAT - @.Typ = o_tym');
        Type = about;
    }
    else if (@.Typ = z_tego)
        Type = from;
    else if (@.Typ = do_tego)
    {
        warning('UNEXPECTED: KORELAT - @.Typ = do_tego');
        Type = to;
    }
    else if (@.Typ = co_do_tego)
    {
        warning('UNEXPECTED: KORELAT - @.Typ = co_do_tego');
        Type = as_for;
    }
}

#
ZŻE => SubC
{
    # 'wiedział, że powiem prawdę' => 'he knew that I would tell the truth'
    'że'=>'that' {warning('UNEXPECTED: ZŻE - że');}
    Type := that;
    delete("CORRELATE",);
    delete('that',);

    $CVP := find("CVP","#");
    $VP := $CVP->find("VP",);

    # 'wiedział o tym, że się spotkają' => 'he knew about the fact that they would meet'
    if($CVP and $VP)
        $CVP->replace_with($VP);
}

ZOB => SubC
{
    # 'nie wiem kiedy pójdę' => 'I don~t know when I will go'
    delete("CORRELATE",);
    $CVP := find("CVP","#");
    $VP := $CVP->find("VP",);

    if($CVP and $VP)
    {
        warning('UNEXPECTED: ZOB $CVP and $VP');
        $CVP->replace_with($VP);
    }
}

#
#
ZBY => SubC
{
    # 'walczył o to, by zbudować most' => 'he struggled for it to build the bridge'
    # 'walczył o to, by przyjechała w poniedziałek' => 'he struggled for it her to arrive on Monday'
    delete("CORRELATE",);
    'by'=>'to' {warning('UNEXPECTED: ZBY - by');}
#

    $CVP := find("CVP","#");
    $VP := $CVP->find("VP",);

    if($Conj := $CVP->find("Conj",) and (($Conj.Person = 1) or ($Conj.Person = 2)))
    {
        # 'poprosił Karola, bym mogła zostać' => 'he asked Karol for me can stay'
        $VP->delete("GNP",subject);
        $VP->insert_default_subject($Conj.Num, $Conj.Person, hum, $Conj.Gender);
    }

    if($CVP and $VP)
         $CVP->replace_with($VP);

    #return 0;

    delete(correlate,);
    delete('to',);
    $VP := find("VP",);
    $V := $VP->find("V","#");
    {
        if(($V.eqv()).C = bezokolicznik)
        {
            Type := in_order_to;
        }
        else
        {
            Type := so_that;
            # $VP->insert_left('so that',);
            $VP->set_tense(present);
            # $V->Tense := present;
        }
    }
    #Jeśli zdanie poprzedzone jest spójnikiem mającym osobę i liczbę (np. byście), a ponadto nie posiada podmiotu,
    #to trzeba ten podmiot domyślny dodać

    #Transfer zdań ze spójnikiem
    if($Conj := find("Conj",) and (($Conj.Num = 1) or ($Conj.Num = 2)))
    {
        warning('UNEXPECTED: ZBY: $Conj := find("Conj",) and (($Conj.Num = 1) or ($Conj. Num = 2))');

        $VP := find("VP", "#");
#
#
#
#
#
#
#
        if(not $VP->find("GNP", subject))
        {
            $NomPron := insert_left("NomPron", subject);
            $NomPron.Num := $Conj.Num;
            $NomPron.Person := $Conj.Person;
            $NomPron.Equiv := "";
            #Jeśli tylko jest to zgodne z semantyką czasownika, to podmiot jest osobowy
            if ($VP.S ^ hum)
                $NomPron.S := hum;
            else
                $NomPron.S := $VP.S;
            #Trzeba ustalić jeszcze rodzaj (Gender) podmiotu - na podstawie przyjętej semantyki i rodzaju czasownika w zdaniu polskim
            if(@.R = ż and S < hum)
                Gender := fem;
            else if((@.R = mo or @.R = "mż") and S < hum)
                Gender := masc;
            else
                Gender := neut;
        }
    }
#
#
#
#
#
#
#
#
}


ZJAK => SubC
{
    # 'kwiecień, jak powiedziałeś' => 'April how, you said'
    'jak'=>'how' {}
    delete("CORRELATE",);
    delete('how',);
    Type := how;
}

#
ZPODRZ => SubC
{
    warning('UNEXPECTED: ZPODRZ');
    if(find(correlate,))
    {
        warning('UNEXPECTED: ZPODRZ - find(correlate,)');
        delete(correlate);
        Type := ob;
    }
}

:prerel => :prerel {}

ZWZGL=> RelC
{
    # 'wszyscy, którzy przyszli byli młodzi' => 'everyone which came were young'
    S := @.S;
    Type := unknown;
    find("VP",)->delete(',',prerel);
}


SFC => VPS
{
    # 'jakbyście mi powiedzieli, to by było dobrze' => 'if you told me, would be well'
    if(@.Pytanie)
    {
        if (find("VP",)->Tense != imperative)
        {
            warning('UNEXPECTED: find("VP",)->Tense != imperative');
            find(,)->Question := 1;
        }
    }

    if ($Prep1 := find("CVP",)->find("Conj",)->Prep1 or $Prep1 := find("GNP",)->ConjType)
    {
        # 'zarówno śmiał się, jak i płakał' => 'both he laughed and cried'
        foreach $S
        {
            if ($Conj:= $S->find("Conj",) and ($Conj->eqv()->Ps1 = 8 or $Conj->eqv()->Ps1 = 9))
            {
                if ($Prep1 = "0")
                {
                    # 'jeśli chodzi o pociągi, to mam o nich złe zdanie' => 'as for trains, I have a bad opinion about them'
                    $Conj->Equiv := "";
                }
                else
                {
                    $Conj->Equiv := $Prep1;
                }
            }
        }
    }
}

FCs => CVP
{
    # 'poprosił, żebym go odwiedziła' => 'he asked me to visit him'
    if(find("Conj",)->Nocomma)
        Nocomma := 1;
}

ZPYT => INTERROGATIVE {}
ZOZN => AFFIRMATIVE {}

WY => EXCL
{
    # 'kurwa!' => 'fuck!'
    if(Equiv =~ /^(.*)!$/)
    {
        # 'cześć, Tereska!' => 'hello, Tereska!'
        Equiv := $1;
    }
}#Trzeba w syntezie morfologicznej wygenerować formy 'this', these'

#!!! TRACE ../../co/trules/czasownik.i

#

#!!! TRACE ../../co/trules/czasownik.m

#


sub ::count_nodes()
{
    # 'widziałem w sklepie Marka' p=>e 'I could see Marek in the shop'
    if(Equiv)
        return 1;

    $c := 0;

    foreach $s
        $c := $c + $s->count_nodes();

    return $c;
}

sub ::count_words()
{
    # 'msza święta celebrowana zwykle rano' p=>e 'Holy Mass celebrated usually in the morning'
    if(Equiv)
        return count_words_in_equiv(Equiv);

    $c := 0;

    foreach $s
        $c := $c + $s->count_words();

    return $c;
}

sub ::count_words_in_equiv(e)
{
    # 'msza święta celebrowana zwykle rano' p=>e 'Holy Mass celebrated usually in the morning'
    if($e =~ /^[^ ]+ (.*)$/)
        return count_words_in_equiv($1) + 1 ;
    else if($e =~ /[^ ]/)
        return 1;
    else
        # 'ustawy przyjęte na mocy niniejszego artykułu' p=>e 'bills passed by virtue of the present article'
        return 0;
}

#!!! TRACE ../../co/trules/czasownik.t

#

#
Hk => Hk { Equiv := "";}

#
#
sub ::pro_hks(p)
{
    $with_slots := 0;
#
    foreach $s
    {
        if($s->cat() = "Hk")
        {
if($slot := $s->find(,slot1))
            {
                warning("UNEXPECTED: co 1: pro_hks");
                $s->delete($slot,);
                $p->insert_right($slot,);
                $slot->change_label(slot1);
                $with_slots := 1;
            }
if($slot := $s->find(,slot2))
            {
                warning("UNEXPECTED: co 2: pro_hks");
                $s->delete($slot,);
                $p->insert_right($slot,);
                $slot->change_label(slot2);
                $with_slots := 1;
            }
if($slot := $s->find(,slot3))
            {
                warning("UNEXPECTED: co 3: pro_hks");
                $s->delete($slot,);
                $p->insert_right($slot,);
                $slot->change_label(slot3);
                $with_slots := 1;
            }
        }
    }

if($s := find(,slot1))
    {
        warning("UNEXPECTED: co 1: pro_hks2");
        delete($s,);
        $p->insert_right($s,);
        $s->change_label(slot1);
        $with_slots := 1;
    }
if($s := find(,slot2))
    {
        warning("UNEXPECTED: co 2: pro_hks2");
        delete($s,);
        $p->insert_right($s,);
        $s->change_label(slot2);
        $with_slots := 1;
    }
if($s := find(,slot3))
    {
        warning("UNEXPECTED: co 3: pro_hks2");
        delete($s,);
        $p->insert_right($s,);
        $s->change_label(slot3);
        $with_slots := 1;
    }

    return $with_slots;
}




#!!! TRACE ../../co/trules/fleksja.i

#


#!!! TRACE ../../co/trules/liczebnik.i

#


#!!! TRACE ../../co/trules/przymiotnik.i



#!!! TRACE ../../co/trules/rzeczownik.i

#

sub ::get_first_word()
{
    if(Equiv)
        return Equiv;
    else
        return find(,)->get_first_word();
}




#!!! TRACE ../../co/trules/rzeczownik.m

#



#!!! TRACE ../../co/trules/shared.i

#

#!!! TRACE ../../co/trules/slots.t
